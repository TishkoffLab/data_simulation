import sys
from pandas import *
import numpy as np
import matplotlib
from matplotlib import pyplot
import itertools as it
import matplotlib.backends.backend_pdf
import math
from matplotlib.pyplot import cm
from dateutil import parser
import scipy
from scipy.stats import mstats
import re
import matplotlib.dates as mdates
import datetime
import msprime as ms
import random
from scipy.stats import norm
from argparse import ArgumentParser
# import pdb

parser = ArgumentParser()
parser.add_argument("-r", "--repetitions", dest="L",
                    help="number of simulated genotypes to run, corrisponding to the number of causal variants")
parser.add_argument("-s", "--samplesize", dest="samp_size",
                    help="number of genotypes that will be simulated for each run")
parser.add_argument("-w", "--window", dest="window",
                    help="window size to use as a spacer between the SNPs generated by the simulation. If the input is not a number, each SNP generated will be on its own chromosome (number = replicate)")
parser.add_argument("-n", "--num_inds", dest="num_individuals",
                    help="number of individuals that will be used to create the genotypes and phenotypes")
parser.add_argument("-l", "--sequence_length", dest="seq_len",
                    help="length of the sequence that will be simulated; the only variant that will be used from this is the causal one")
parser.add_argument("-b", "--beta", dest="beta_type",
                    help="string keyword that corrisponds to how we want to assign the beta value for the phenotype (ie constant means the beta value will be the same for all causal variants)")
parser.add_argument("-o", "--out", dest="out_name",
                    help="name of the file to be saved, the files <out_name>.phenodist.png, <out_name>.pheno.vcf, <out_name>.geno.vcf and <out_name>.phenotypes  will be created")
parser.add_argument("-f", "--file", dest="input_file",
                    help="the name of the file that contains the epochs that we will be simulating. The file format is described in the read_input_file function description.")
parser.add_argument("-m", "--mutrate", dest="mutation_rate",
                    help="rate of mutation to use for simulation.")
parser.add_argument("-c", "--recombrate", dest="recombination_rate",
                    help="rate of recombination to use for simulation.")


# assign_genotype_index((num_individuals*num_pops),(num_individuals*num_pops)*2)
#Take the genotypes that are simulated, and assign two of the indexes to each individual.
#samp_sizes: number of individuals that you want to sample, an array of length P
#pop_sizes: Total number of genotypes in each population that you are simulating, an array of length P. Each entry must be at least double the entry in samp_sizes
def assign_genotype_index_multipop(samp_sizes,pop_sizes):
    for i,s in enumerate(samp_sizes):
        if(pop_sizes[i] < (2*s)):
            print('number of genotypes in population {0} is not at least double the number of individuals you are simulating! {1} < {2}'.format(i,pop_sizes[i],(s*2)))
            return -1
    ind_haps_dict_bypop = {x:[] for x in range(len(pop_sizes))}
    x = sum(pop_sizes)
    prev_indstart = 0
    for n,p in enumerate(pop_sizes):
        num_inds_tosample = samp_sizes[n]
        curr_popinds = []
        for x in range(p):
            curr_popinds.append(x + prev_indstart)
        
        popinds_used = []
        temp_popinds = []
        for x in range(num_inds_tosample):
            curr_haps = []
            while (len(curr_haps) != 2):
                temp_seq_num = random.randint(min(curr_popinds),max(curr_popinds))
                if(temp_seq_num not in popinds_used and temp_seq_num not in curr_haps):
                    curr_haps.append(temp_seq_num)
                    popinds_used.append(temp_seq_num)
            temp_popinds.append(curr_haps)
        ind_haps_dict_bypop[n] = temp_popinds
        prev_indstart += p
    return ind_haps_dict_bypop

#Reads in a migration matrix file. File format is #<epoch_num>, followed by a number of lines equal to the population number with the migration value of that 
#population against all others (must have zeros along axis); for each epoch
#    filename (string): name of the migration matrix file. Should be equal to <input_file>.migration_matrix, in the same folder as the <input_file>.epoch file
#    num_epochs (int): number of epochs
#Returns migmats_byepoch: a list of matrices, one matrix per epoch
def read_input_migrationmatrix(filename,num_epochs):
    mfile = open(filename,'r')
    migmats_byepoch = [[] for x in range(num_epochs)]
    for line in mfile:
        if(line[0] == '#'):
            curr_migmat = int(line[1])
        else:
            curr_mm = np.array([float(f) for f in line.split('\n')[0].split('\t')])
            migmats_byepoch[curr_migmat].append(curr_mm)
    mfile.close()
    return migmats_byepoch

#Reads in a file that has the epochs that we want to simulate. The file needs to be in a tab-seperated file, with a header.
#The file needs to be named <filename>.epochs
#Each line after the header represents 1 epoch. Necessary columns include:
#time: starting time of the epoch
#init_pops: the number of people in each population that will be simulated
#num_pops: the number of different populations that we want to simulate
#migration_rate: the rate of migration for the epoch. This is only necessary if you want to 
def read_input_file(filename):
    input_df = read_csv('{0}.epochs'.format(filename),sep='\t')
    num_theta = len(input_df)
    theta_true = []
    sample_scheme_byepoch = []
    migmat_fromfile = None
    try:
        mm_file = '{0}.migration_matrix'.format(filename)
        migmat_fromfile = get_input_migrationmatrix(filename,num_theta)
    except:
        pass
    # Set the demographic model parameters (theta)...
    for epoch,t in input_df.iterrows():
        Np = len(t['pop_scheme'].split(','))               # Num pops
        pop_sizes = [int(x) for x in t['pop_scheme'].split(',')]    # Num of samples per population in the observed data
        sample_scheme = [int(x) for x in t['pop_scheme'].split(',')]   # Num samples drawn from each pop for likelihood

        # pop sizes
        if(migmat_fromfile is None):
            N_base = 1e4    # Number of diploids in the population
            Ne0 = np.ones(Np)*N_base
            # Set migration rates
            M_base = float(t['migration_rate'])
            m = np.zeros((Np,Np))
            for i in range(Np):
                for j in range(Np):
                    if j!=i:
                        m[i,j] = M_base/(2*(Np-1))
            theta_true.append([float(t['time']),[Ne0,m]])
        else:
            theta_true.append([float(t['time']),migmat_fromfile[epoch]])
        sample_scheme_byepoch.append(pop_sizes)

    return theta_true,sample_scheme_byepoch


#Reads in a file that has the epochs that we want to simulate. The file needs to be in a tab-seperated file, with a line per epoch, each one followed by a migration matrix outlining the migration values for each population pair
#Each line that indicates an epoch should start with a '#' symbol, followed immediately by the time of the start of the epoch, then a tab, then the population sizes seperated by commas (for example: 4,4,5 for 3 populations of that number of individuals)
#Following the line with the time/population sizes, the migration matrix which is of size NxN, where N=number of populations. The diagonal of the matrix should be zeros.
#   filename (str): name of the input file to read
#returns:
#   theta_true: description can be found in the run_
def read_input_file_full(filename):
    infile = open(filename,'r')
    theta_true = []
    sample_scheme_byepoch = []
    curr_epoch = -1
    migmats_byepoch = {}
    times_byepoch = []
    for line in infile:
        if(line[0] == '#'):
            curr_epoch += 1
            curr_time = line.split('\n')[0][1:].split('\t')[0]
            times_byepoch.append(float(curr_time))
            curr_popscheme = line.split('\n')[0][1:].split('\t')[1]
            pop_sizes = [int(x) for x in curr_popscheme.split(',')]    # Num of samples per population in the observed data
            sample_scheme_byepoch.append(pop_sizes)
        else:
            curr_mm = [float(f) for f in line.split('\n')[0].split('\t')]
            if(curr_epoch not in migmats_byepoch.keys()):
                migmats_byepoch[curr_epoch] = []
            migmats_byepoch[curr_epoch].append(curr_mm)
    # pop sizes
    N_base = 1e4    # Number of diploids in the population
    
    for e in range(len(sample_scheme_byepoch)):
        Ne0 = np.ones(len(sample_scheme_byepoch[e]))*N_base
        theta_true.append([times_byepoch[e],[Ne0,np.array(migmats_byepoch[e])]])

    return theta_true,sample_scheme_byepoch

#Runs the msprime simulate function, taking into account the 
#theta: the list of epochs that we want to simulate. Each entry is equal to one epoch; each entry has:
#  0: Starting time of the epoch
#  1: List with two items: Total Population size at start of epoch, and migration matrix
#    Migration Matrix: NxN (where N = Number of Populations, Np), Rate of migration between each population
#sample_nums: Array of population sizes, of length Np; the number of samples drawn from the population
#L: Length of the sequence we will be simulating
#r: Recombination rate, constant accross all populations
#mu: Mutation rate, constant accross all populations
#R: Number of replicates; msprime will run R simulations and return an iterator over all trees created
#Updated: Return list of ts_replicates; each entry will be the simulations for each epoch
def run_msprime_tskit(theta,sample_nums,L,r,mu,R):
    ts_rep_list = []
    ts_replicates = None
    
    Np = len(sample_nums)
    # print('samples to be drawn for populations: {0}'.format(sample_nums))
    # print([[sample_nums[i], theta[0][1][0][i]] for i in range(Np)])
    init_pop_configs = [ms.PopulationConfiguration(sample_size=sample_nums[i], initial_size=theta[0][1][0][i]) for i in range(Np)]
    
    init_mig = theta[0][1][1]
    
    K = len(theta)  # K = number of epochs
    if K > 1:
        # There is more than one epoch, so must set the non-initial epochs as demographic events
        demo_events = []
        for k in range(1,K):
            t_k,theta_k = theta[k]
            Ne = theta_k[0]
            mig = theta_k[1]
            for i in range(Np):
                # Set the Ne
                demo_events.append(ms.PopulationParametersChange(population=i,time=t_k,initial_size=Ne[i]))

                # Set the migration rates
                for j in range(Np):
                    if j!=i:
                        demo_events.append(ms.MigrationRateChange(time=t_k,rate=mig[i,j],matrix_index=tuple([i,j])))

        ts_replicates = ms.simulate(
            length=L,
            recombination_rate=r,
            population_configurations=init_pop_configs,
            migration_matrix = init_mig,
            demographic_events=demo_events,
            num_replicates=R,
            mutation_rate = mu
        )
    else:
        # There is only the initial epoch. 
        ts_replicates = ms.simulate(
            length=L,
            recombination_rate=r,
            population_configurations=init_pop_configs,
            migration_matrix = init_mig,
            num_replicates=R,
            mutation_rate = mu
        )
    return ts_replicates

#Given a list of indexes to draw from and a number of individuals to draw, returns a randomly assigned list of 2 indexes per person
#This is used to create the haplotypes from single population
#    samp_size: list of the indexes that are available, and will be distributed to the individuals. Should be >=(2*num_inds)
#    num_inds: number of people that we want to assign indexes to. Each individual will have 2 indexes at the end
#returns ind_haps_dict: a dictionary. The keys are the individuals (a number for each), and the values are tuples where each number corrisponds to a position in the genotype list.
def assign_genotype_index(samp_size,num_inds):
    ind_haps_dict = {}
    haps_used = []
    for n in range(num_inds):
        curr_haps = []
        while (len(curr_haps) != 2):
            temp_seq_num = random.randint(0,(samp_size-1))
            if(temp_seq_num not in haps_used and temp_seq_num not in curr_haps):
                curr_haps.append(temp_seq_num)
                haps_used.append(temp_seq_num)
        ind_haps_dict[n] = curr_haps
    return ind_haps_dict


#Returns a phenotype value for the indivudal with the genotypes provieded; the sum of all the causal genotypes multiplied by the beta value
#    genotypes: list of tuples, where the tuples contain values of 0 or 1. These tuples are each the genotype for a signle individual from the causal SNP in each replicate.
#    beta: a float, representing the genetic component for the individual. Drawn from a distribution of values, but this could be altered as needed.
def estimate_pheno(genotypes,betas_byrep):
    full_phenovals = []
    for rep,g in enumerate(genotypes):
        try:
            c_al1 = float(g[0])
            c_al2 = float(g[1])
            full_phenovals.append((c_al1 + c_al2)*betas_byrep[rep])
        except:
            print("Error!",g)
    return sum(full_phenovals)

#Plots the distribution of phenotype values for all the individuals as a histogram, as well as a line representing a normal distribution over those bins, for verification
#  x-axis is the phenotype value, and the y-axis is the number of individuals in the bin
#    pheno_dict: dictionary of the phenotypes for the individuals. Keys are the individuals (as sequential integers), values are phenotype for that individual (as a float)
#    outname: the name of the file to save the plot as, in the format of <outname>.phenodist.png
def plot_phenodist(pheno_dict,outname):
    pheno_df = DataFrame(pheno_dict.values(),index=pheno_dict.keys(),columns=['Pheno_value'])

    mu, std = norm.fit(pheno_df['Pheno_value'])

    pyplot.hist(pheno_df['Pheno_value'])

    xmin, xmax = pyplot.xlim()
    x = np.linspace(xmin, xmax, 100)
    p = (norm.pdf(x, mu, std))*(len(pheno_dict)*2)
    pyplot.plot(x, p, 'k', linewidth=2)
    title = "Fit results: mu = %.2f,  std = %.2f" % (mu, std)
    pyplot.title(title)
    pyplot.ylabel('Number of Individuals in Bin')
    pyplot.xlabel('Phenotype Value')
    pyplot.savefig('{0}.phenodist.png'.format(outname))

#Get a distribution of values to use as betas for the phenotype calculation
#  right now, it only has one kind of distribution that it can generate, but in the future we can add different kinds of distributions to generate
#    num_inds (int): number of individuals, the distribution will generate this number of values.
#returns dist: an array of length <num_inds>, each position corrisponds to the beta for the individual with that number as their ID.
def generate_betas(num_inds,dist_type='normal'):
    if(dist_type == 'normal'):
        dist = np.random.normal(0,0.1,num_inds)
    return dist

#Saves the phenotype file. It is a tab-seperated file with 2 columns; the first column is the ID of the individual, and the second column is the phenotype value for that individual
#  IDs are converted from a single int into ID<id_num> for compliance with plink id restrictions. If there are multiple populations, it will be converted to POP<pop_num>ID<id_num>
#    outname: name of the file that it will be saved as, <outname>.phenotypes
#    pheno_dict: dictionary of phenotype values per individual. Keys are the individual ID number, and values are the phenotype vaule (a float)
#    popid_dict: dictionary of the individual to their population number. Keys are the individual ID number, and the value is the population id that they belong to (int). If it is not
#                provided, then there is only one population and this variable is ignored.
def write_phenofile(outname,pheno_dict,popid_dict=None):
    pheno_file = open('{0}.phenotypes'.format(outname),'w')
    if(popid_dict == None):
        new_ids = []
        for i in range(len(pheno_dict.items())):
            new_ids.append(''.join(['ID',str(i)]))
    else:
        new_ids = []
        for i,pop in popid_dict.items():
            new_ids.append(''.join(['POP',str(pop),'ID',str(i),]))
    for ind,p in pheno_dict.items():
        pheno_file.write('{0}\t{1}\n'.format(new_ids[ind],p))
    pheno_file.close()

#Runs the msprime simulation that generates phenotypes, as well as saves the genotypes that were used to create that phenotypes as a vcf file. 
#  This function is only used if there is a single population and only one time period.
#    samp_size (int): number of genomes to simulate, should be at least double the num_individuals
#    seq_len (int): length of the sequence that will be simulated
#    L (int): number of replicates to use in generating the simulation
#    num_individuals (int): number of people that we want to simulate phenotypes/genotypes for, 2 genomes per person
#    outname: name of the file that will be saved
#    beta: type of distribution that will be used to pull beta values from
#    causal_var_id: the id of the variant that will be used as the causal variant. Defaults to 1, meaning the first variant will be counted as the causal variants.
def run_pheno_simulation(samp_size,seq_len,L,num_individuals,outname,beta,causal_var_id=1):
    genotype_index_byinds = assign_genotype_index(samp_size,num_individuals) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
    causalgenotypes_byind = {x:[] for x in range(num_individuals)} #Stores the genotypes, as a list of tuples (each tuple is (0,0), (1,1), (1,0), or (0,1)), for each individual. Keys are the individual ID, values are the genotype lists
    causalgenotypes_byrep = {x:[] for x in range(L)}  #Each repetition, add the genotype from that rep (as a tuple) to this dictionary. Then we can just iterate through the list of values to generate the final phenotype
    fullgenotypes_byrep = {x:{} for x in range(L)} #Store the full list of genotypes of all individuals for each variant position for each repetition. Keys are repetition number, values are a dictionary of the variants created in that replication.
    causalpositions_byrep = {x:0 for x in range(L)} #A dictionary of the positions that we consider as the causal snp in the repetition. Keys are the repetition number, value is the position of the variant (an int)
    rep = 0
    while (rep < L):
        tree_sequence = msprime.simulate(sample_size=samp_size, Ne=1e4, length=seq_len, recombination_rate=2e-8,mutation_rate=2e-8) 
        curr_causal_var = []
        curr_causal_pos = ''
        curr_full_vars_posgeno_dict = {}
        for variant in tree_sequence.variants():
            curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
            if(variant.site.id == causal_var_id):
                curr_causal_var = list(variant.genotypes)
                curr_causal_pos = round(variant.site.position)
        if(len(curr_causal_var) != samp_size):
            print('no causal variants in rep {0}, redoing'.format(rep))
            rep -= 1
            continue

        causalpositions_byrep[rep] = curr_causal_pos
        curr_rep_genotypes = []
        for indiv,index in genotype_index_byinds.items():
            try:
                causalgenotypes_byind[indiv].append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
                curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
            except:
                print(indiv,index)
        causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

        curr_rep_fullgenos = {}
        for pos,geno in curr_full_vars_posgeno_dict.items():
            temp_fullgeno = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                except:
                    print(indiv,index)
            curr_rep_fullgenos[pos] = temp_fullgeno
        fullgenotypes_byrep[rep] = curr_rep_fullgenos
        rep += 1

    phenotypes_byinds = {x:0 for x in range(num_individuals)}
    beta_list = generate_betas(num_inds=num_individuals,dist_type=beta)
    for i in range(num_individuals):
        curr_beta = beta_list[i]
        phenotypes_byinds[i] = estimate_pheno(causalgenotypes_byind[i],curr_beta)

    plot_phenodist(phenotypes_byinds,num_individuals,outname)
    write_phenofile(outname,phenotypes_byinds)

    return causalpositions_byrep,fullgenotypes_byrep


    

#Runs the msprime simulation that generates genotypes and saves them as a vcf file. 
#  This function is only used if there is a single population and only one time period.
#    samp_size (int): number of genomes to simulate, should be at least double the num_individuals
#    seq_len (int): length of the sequence that will be simulated
#    L (int): number of replicates to use in generating the simulation
#    num_individuals (int): number of people that we want to simulate phenotypes/genotypes for, 2 genomes per person
#    outname: name of the file that will be saved
#    causal_var_id: the id of the variant that will be used as the causal variant. Defaults to 1, meaning the first variant will be counted as the causal variants.
def run_geno_simulation(samp_size,seq_len,L,num_individuals,causal_var_id=1):
    genotype_index_byinds = assign_genotype_index(samp_size,num_individuals) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
    causalgenotypes_byrep = {x:[] for x in range(L)} #Each repetition, add the genotype from that rep (as a tuple) to this dictionary. Then we can just iterate through the list of values to generate the final phenotype
    fullgenotypes_byrep = {x:[] for x in range(L)}
    causalpositions_byrep = {x:0 for x in range(L)}
    rep = 0
    while (rep < L):
        tree_sequence = msprime.simulate(sample_size=samp_size, Ne=1e4, length=seq_len, recombination_rate=2e-8,mutation_rate=2e-8) 
        num_vars = 0
        for variant in tree_sequence.variants():
            num_vars += 1
        if(num_vars == 0):
            print('no variants in rep {0}, redoing'.format(rep))
            rep = rep-1
            continue
        causal_var_id = random.randint(0,(num_vars-1))
        curr_causal_var = []
        curr_causal_pos = 0
        curr_full_vars_posgeno_dict = {}
        for variant in tree_sequence.variants():
            curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
            if(variant.site.id == causal_var_id):
                curr_causal_var = list(variant.genotypes)
                curr_causal_pos = round(variant.site.position)

        if(len(curr_causal_var) != samp_size):
            print('no causal variants in rep {0}, redoing'.format(rep))
            rep -= 1
            continue
        causalpositions_byrep[rep] = curr_causal_pos
        curr_rep_genotypes = []
        for indiv,index in genotype_index_byinds.items():
            try:
                curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
            except:
                print(indiv,index)
        causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

        curr_rep_fullgenos = {}
        for pos,geno in curr_full_vars_posgeno_dict.items():
            temp_fullgeno = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                except:
                    print(indiv,index)
            curr_rep_fullgenos[pos] = temp_fullgeno
        fullgenotypes_byrep[rep] = curr_rep_fullgenos

        rep += 1
    return causalpositions_byrep,fullgenotypes_byrep


#Writes a genotype to a vcf file. As a default, the variants will be outputted as being on a single chromosome (chrm 1) and having a position equal to their simulated position plus a padding of (window_spacer+seq_len)*(replicate number) 
#    full_geno_dict: dictionary containing the full genotypes for a simulation, for all replicates. Keys are the replicate number, values are dictionaries of positions to genotypes. The fullgenotypes_byrep is what is being passed here.
#    causal_pos_dict: dictionary with the causal variant position for each replicate. Keys are the replicate number, value is an int representing the variant that is the causal SNP.
#    outname: name of the vcf file that will be saved, formatted as <outname>.vcf
#    seq_len: length of the sequence that was simulated. This is used to determine the full length of the simulated vcf, for the header, and to properly determine the position of each SNP as we record it
#    window_spacer: length of bases that will be used to pad the positions between each replicate. Future functionality will allow the user to specify that each replicate will be on their own chromosome (number = replicate number), rather than have a window spacer.
#    popid_dict: a dictionary that is only passed if the simulation has multiple populations. Keys are the individual ID, values are the population ID that they belong to.
#        This will be used to write the ID to the VCF, formatted as POP<population_id>ID<individual_id>. If this is not passed to this function, the format of the ID is ID<individual_id>
def write_genovcf(full_geno_dict,causal_pos_dict,outname,seq_len,window_spacer=1000,popid_dict=None):
    use_diff_chrms = False
    if(window_spacer == 'chrm'):
        window_spacer = 0
        use_diff_chrms = True
    full_len = len(full_geno_dict)*(window_spacer+seq_len)
    header_string = '##fileformat=VCFv4.2 \n##source=tskit 0.2.2 \n##FILTER=<ID=PASS,Description="All filters passed"> \n##INFO=<ID=CS,Number=0,Type=Flag,Description="SNP Causal to Phenotype"> \n##contig=<ID=1,length={0}>\n##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype"> \n'.format(full_len)
    vcf_file = open('{0}.vcf'.format(outname),'w')
    vcf_file.write(header_string)
    vcf_file.write('#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t')
    if(popid_dict == None):
        new_ids = []
        for i in range(len(geno_dict[0][1])):
            curr_nid = ''.join(['ID',str(i)])
            new_ids.append(curr_nid)
            vcf_file.write('{0}\t'.format(curr_nid))
        vcf_file.write('\n')
    else:
        new_ids = []
        for i,pop in popid_dict.items():
            curr_nid = ''.join(['POP',str(pop),'ID',str(i),])
            new_ids.append(curr_nid)
            vcf_file.write('{0}\t'.format(curr_nid))
        vcf_file.write('\n')
    for rep,geno_dict in full_geno_dict.items():
        is_rep_causalsnp = False
        for pos,genos in geno_dict.items():
            try:
                if(use_diff_chrms == True):
                    chrm_touse = rep
                else:
                    chrm_touse = 1
                curr_pos = (int(rep)*(window_spacer+seq_len))+pos
                if(pos == causal_pos_dict[rep]):
                    is_rep_causalsnp = True
                    vcf_file.write('{0}\t{1}\t.\tA\tG\t.\tPASS\tCS\tGT\t'.format(rep,curr_pos))
                else:
                    vcf_file.write('{0}\t{1}\t.\tA\tG\t.\tPASS\t.\tGT\t'.format(rep,curr_pos))
                for g in genos:
                    vcf_file.write('{0}|{1}\t'.format(g[0],g[1]))
                vcf_file.write('\n')
            except:
                print(rep,genos)
    vcf_file.close()
        
#Assigns individual ID numbers to the populations. IDs will be assined sequentially, so if pop 0 has a size of 4, IDs 0,1,2,3 will be assigned to pop 0.
#    pop_sizes: list of ints, where each int is the population size of the population corrisponding to its position in the list
#returns pop_assign: a list of lists; each list has the individual ID numbers assigned to the population corrisponding to the position in this list
def assign_pop_inds(pop_sizes):
    pop_assign = []  # row index = pop index. value = list of indices of samples assigned to each pop.
    j = 0
    for i in range(len(pop_sizes)):
        Ni = pop_sizes[i]
        indices = list(range(j,j+Ni))
        pop_assign.append(indices)
        j+=Ni
    return pop_assign   

#Assigns each individual ID number to the population it belongs to. This will be the same population assignment as made by the assign_pop_inds() function
#    pop_scheme: list of ints, where each int is the population size of the population corrisponding to its position in the list
#returns popindex_byind: a dictionary; keys are the individual ID number, the value is the population number that individual belongs to
def assign_popdict(pop_scheme):
    full_sampsize = sum(pop_scheme)
    popindex_byind = {x:0 for x in range(full_sampsize)}
    for pop,size in enumerate(pop_scheme):
        for x in range(size):
            popindex_byind[(x + (size*pop))] = pop
    return popindex_byind

#For the multi-population simulation, takes the dictionary that has the genotype indexes grouped by populations, and returns a dictionary with the genotype index for each individual
#    genoind_bypops: dictionary; keys are the population id, values are a list. Each list has the genotype indexes (as in the position within the genotype list) that is assigned to each individual within that population
#returns ind_genoindex_dict: dictionary; keys are the individual ID, values are a tuple of the two indexes that are assigned to that individual
def get_ind_genoindex_multipop(genoind_bypops):
    ind_genoindex_dict = {}
    prev_pn = 0
    for num,p in enumerate(genoind_bypops.items()):
        for i,g in enumerate(p[1]):
            ind_genoindex_dict[(prev_pn+i)] = g
        prev_pn += len(p[1])
    return ind_genoindex_dict

#msprime does not do well if the migration matrix has all zeros for the migration between each population pair, so we don't want to run a simulation where the final theta has an all-zero migration matrix
#This funtion checks if that is the case for all the thetas that you are going to check, and returns the indexes of those bad thetas
#    theta: corrisponds to the values that make up each epoch. See the comments for the run_msprime_tskit() function for a more thorough description of this variable
#return bad_theta_nums: list; ints corrisponding to the thetas that shouldn't be used as the final epoch
def thetas_toskip(theta):
    bad_theta_nums = []
    for epoch in range(len(theta)):
        curr_theta = theta[:epoch+1]
        if(set([all(x == 0) for x in curr_theta[-1][1][1]]) == {True}):
        # if(set(curr_theta[-1][1][1]) == {0}):
            bad_theta_nums.append(epoch)
    return bad_theta_nums


#Runs the phenotype-generating simulation, for multiple populations and multiple epochs
#    theta: list of variables, each entry indicates an epoch. See the description for run_msprime_tskit() to see the full details of this variable
#    seq_len (int): length of the sequence that will be simulated
#    reps (int): number of replicates to simulate
#    pop_schemes (list): list of ints, one per population that will be simulated, indicating the number of individuals that will have 2 genotypes assigned to each
#    r (float): recombination rate, provided to the simulate function
#    mu (float): mutation rate, provided to the simulate function
#    outname (string): name of the file that will be created with the phenotype, one per epoch that is provided, as <outname>.epoch<num_epoch>.phenotypes
#    beta (string): method of choosing the beta value that is assigned to each individual. The only kind of distribution that is implemented so far
#Returns a 2 lists of dictionaries; per epoch. 
#    causalpos_byepoch: for each replicate in the epoch, contains the position that was used to calculate the phenotype. Used to indicate in the output vcf file which SNP is the causal one
#    genos_byepoch: for each replicate in each epoch, has a dictionary containing the full genotypes for all variants
def run_pheno_simulation_multipops(theta,seq_len,reps,pop_schemes,r,mu,outname,beta='normal'):
    
    genos_byepoch = []
    causalpos_byepoch = []
    epochs_toskip = thetas_toskip(theta)
    for epoch in range(len(theta)):
        print('Starting epoch {0} replicates'.format(epoch))

        pop_sizes = [(i*2) for i in pop_schemes[epoch]] # Num individuals simulated, equal to twice the number of individuals, since each person is diploid
        sample_scheme = [i for i in pop_schemes[epoch]] # Num samples drawn from each pop for likelihood
        full_sampsize = sum(sample_scheme)
        # print(pop_sizes,sample_scheme)
        genotype_index_bypops = assign_genotype_index_multipop(sample_scheme,pop_sizes) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
        genotype_index_byinds = get_ind_genoindex_multipop(genotype_index_bypops)
        # print(genotype_index_byinds)
        causalgenotypes_byrep = {x:[] for x in range(reps)}
        causalpositions_byrep = {x:0 for x in range(reps)}
        fullgenotypes_byrep = {x:[] for x in range(reps)}


        curr_theta = theta[:epoch+1]
        if(epoch in epochs_toskip):
            print('Epoch {0} has no migration, skipping this epoch due to memory constraints'.format(epoch))
            continue
        # print('epoch {0} theta = {1}'.format(epoch,curr_theta))
        tsreps = run_msprime_tskit(curr_theta,pop_sizes,seq_len,r,mu,reps)
        # pdb.set_trace()
        print('replicate trees created; iterating through genotypes now')

        for rep,tree_sequence in enumerate(tsreps): 
            # pdb.set_trace()
            # print('starting replicate {0}'.format(rep))
            num_vars = 0
            for variant in tree_sequence.variants():
                num_vars += 1
            causal_var_id = random.randint(0,(num_vars-1))
            curr_causal_var = []
            curr_causal_pos = 0
            curr_full_vars_posgeno_dict = {}
            for variant in tree_sequence.variants():
                curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
                if(variant.site.id == causal_var_id):
                    curr_causal_var = list(variant.genotypes)
                    curr_causal_pos = round(variant.site.position)

            if(len(curr_causal_var) != (full_sampsize*2)):
                print('not enough causal variants in rep {0}'.format(rep))
                curr_causal_var = [0 for x in range((full_sampsize*2))]
                curr_full_vars_posgeno_dict[0] = [0 for x in range((full_sampsize*2))]
            causalpositions_byrep[rep] = curr_causal_pos

            curr_rep_genotypes = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
                except:
                    print(indiv,index,len(curr_causal_var))
            causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

            curr_rep_fullgenos = {}
            for pos,geno in curr_full_vars_posgeno_dict.items():
                temp_fullgeno = []
                for indiv,index in genotype_index_byinds.items():
                    try:
                        temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                    except:
                        print(rep,indiv,index,len(geno))
                curr_rep_fullgenos[pos] = temp_fullgeno
            fullgenotypes_byrep[rep] = curr_rep_fullgenos

        print('finished iterating through trees, starting the phenotype calculations')
        causalgenotypes_byind = {x:[] for x in range(full_sampsize)}
        for pos,genos in causalgenotypes_byrep.items():
            for num,g in enumerate(genos[1]):
                causalgenotypes_byind[num].append(g)

        beta = 'normal'
        phenotypes_byinds = {x:0 for x in range(full_sampsize)}
        beta_list = generate_betas(num_inds=reps,dist_type=beta)
        for i in range(full_sampsize):
            # curr_beta = beta_list[i]
            phenotypes_byinds[i] = estimate_pheno(causalgenotypes_byind[i],beta_list)
        # phenos_byepoch.append(phenotypes_byinds)
        write_phenofile('{0}.epoch{1}'.format(outname,epoch),phenotypes_byinds)
        
        genos_byepoch.append(fullgenotypes_byrep)
        causalpos_byepoch.append(causalpositions_byrep)
    
    return causalpos_byepoch,genos_byepoch


if __name__ == "__main__":
    args = parser.parse_args()
    if(args.beta_type is None):
        beta = "normal"
    else:
        beta = args.beta_type

    if(type(args.window) == str):
        window = 'chrm'
    else:
        window = int(args.window)

    if(args.input_file is None):
        cpos_pheno_byinds,pgenos_byinds = run_pheno_simulation(int(args.samp_size),int(args.seq_len),int(args.L),int(args.num_individuals),args.out_name,beta)
        write_genovcf(pgenos_byinds,cpos_pheno_byinds,'{0}.pheno'.format(args.out_name),int(args.num_individuals),int(args.seq_len),window)

        cpos_geno_byind,genos_byinds = run_geno_simulation(int(args.samp_size),int(args.seq_len),int(args.L),int(args.num_individuals))
        write_genovcf(genos_byinds,cpos_geno_byind,'{0}.geno'.format(args.out_name),int(args.num_individuals),int(args.seq_len),window)
    else:
        
        # theta,sample_schemes = read_input_file(args.input_file)
        theta,sample_schemes = read_input_file_full(args.input_file)
        popdicts_by_epoch = {}
        epochs_toskip = thetas_toskip(theta)
        for ep,sampsch in enumerate(sample_schemes):
            if(ep in epochs_toskip):
                continue
            popdicts_by_epoch[ep] = assign_popdict(sampsch)
        cpos_pheno_byinds,pgenos_byinds = run_pheno_simulation_multipops(theta,int(args.seq_len),int(args.L),sample_schemes,float(args.recombination_rate),float(args.mutation_rate),args.out_name,beta)
        curr_epoch = 0
        for epoch,pg in enumerate(pgenos_byinds):
            #Since we don't run a simulation where the final migration matrix is all zero, we want the output vcf files to match up with the output phenotypes
            while curr_epoch in epochs_toskip:
                curr_epoch += 1
            print('starting creation of vcf for epoch {0} simulation'.format(curr_epoch))
            curr_popid_dict = popdicts_by_epoch[curr_epoch]
            write_genovcf(full_geno_dict=pg,
                causal_pos_dict=cpos_pheno_byinds[epoch],
                outname='{0}.epoch{1}.pheno'.format(args.out_name,curr_epoch),
                seq_len=int(args.seq_len),
                window_spacer=window,
                popid_dict=curr_popid_dict)
            curr_epoch += 1
    














