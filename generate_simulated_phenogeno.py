import sys
from pandas import *
import numpy as np
import matplotlib
from matplotlib import pyplot
import itertools as it
import matplotlib.backends.backend_pdf
import math
from matplotlib.pyplot import cm
from dateutil import parser
import scipy
from scipy.stats import mstats
import re
import matplotlib.dates as mdates
import datetime
import msprime as ms
import random
from scipy.stats import norm
from argparse import ArgumentParser
# import pdb

parser = ArgumentParser()
parser.add_argument("-r", "--repetitions", dest="L",
                    help="number of simulated genotypes to run, corrisponding to the number of causal variants")
parser.add_argument("-s", "--samplesize", dest="samp_size",
                    help="number of genotypes that will be simulated for each run")
parser.add_argument("-w", "--window", dest="window",
                    help="window size to use as a spacer between the SNPs generated by the simulation. If the input is not a number, each SNP generated will be on its own cromosome (number = replicate)")
parser.add_argument("-n", "--num_inds", dest="num_individuals",
                    help="number of individuals that will be used to create the genotypes and phenotypes")
parser.add_argument("-l", "--sequence_length", dest="seq_len",
                    help="length of the sequence that will be simulated; the only variant that will be used from this is the causal one")
parser.add_argument("-b", "--beta", dest="beta_type",
                    help="string keyword that corrisponds to how we want to assign the beta value for the phenotype (ie constant means the beta value will be the same for all causal variants)")
parser.add_argument("-o", "--out", dest="out_name",
                    help="name of the file to be saved, the files <out_name>.phenodist.png, <out_name>.pheno.vcf, <out_name>.geno.vcf and <out_name>.phenotypes  will be created")
parser.add_argument("-f", "--file", dest="input_file",
                    help="the name of the file that contains the epochs that we will be simulating. The file format is described in the read_input_file function description.")
parser.add_argument("-m", "--mutrate", dest="mutation_rate",
                    help="rate of mutation to use for simulation.")
parser.add_argument("-c", "--recombrate", dest="recombination_rate",
                    help="rate of recombination to use for simulation.")


# assign_genotype_index((num_individuals*num_pops),(num_individuals*num_pops)*2)
#Take the genotypes that are simulated, and assign two of the indexes to each individual.
#samp_sizes: number of individuals that you want to sample, an array of length P
#pop_sizes: Total number of genotypes in each population that you are simulating, an array of length P. Each entry must be at least double the entry in samp_sizes
def assign_genotype_index_multipop(samp_sizes,pop_sizes):
    for i,s in enumerate(samp_sizes):
        if(pop_sizes[i] < (2*s)):
            print('number of genotypes in population {0} is not at least double the number of individuals you are simulating! {1} < {2}'.format(i,pop_sizes[i],(s*2)))
            return -1
    ind_haps_dict_bypop = {x:[] for x in range(len(pop_sizes))}
    x = sum(pop_sizes)
    for n,p in enumerate(pop_sizes):
        num_inds_tosample = samp_sizes[n]
        curr_popinds = []
#         print(n,p,num_inds_tosample)
        for x in range(p):
            curr_popinds.append(x + (n*p))
        popinds_used = []
        temp_popinds = []
        for x in range(num_inds_tosample):
            curr_haps = []
            while (len(curr_haps) != 2):
                temp_seq_num = random.randint(min(curr_popinds),max(curr_popinds))
                if(temp_seq_num not in popinds_used and temp_seq_num not in curr_haps):
                    curr_haps.append(temp_seq_num)
                    popinds_used.append(temp_seq_num)
            temp_popinds.append(curr_haps)
        ind_haps_dict_bypop[n] = temp_popinds
    return ind_haps_dict_bypop

#Reads in a file that has the epochs that we want to simulate. The file needs to be in a tab-seperated file, with a header.
#Each line after the header represents 1 epoch. Necessary columns include:
#time: starting time of the epoch
#init_pops: the number of people in each population that will be simulated
#num_pops: the number of different populations that we want to simulate
#migration_rate: the rate of migration for the epoch
def read_input_file(filename):
    input_df = read_csv(filename,sep='\t')
    num_theta = len(input_df)
    theta_true = []
    sample_scheme_byepoch = []
    # Set the demographic model parameters (theta)...
    for epoch,t in input_df.iterrows():
        Np = len(t['pop_scheme'].split(','))               # Num pops
        pop_sizes = [int(x) for x in t['pop_scheme'].split(',')]    # Num of samples per population in the observed data
        sample_scheme = [int(x) for x in t['pop_scheme'].split(',')]   # Num samples drawn from each pop for likelihood

        # pop sizes
        N_base = 1e4    # Number of diploids in the population
        Ne0 = np.ones(Np)*N_base

        # Set migration rates
        M_base = float(t['migration_rate'])
        m = np.zeros((Np,Np))
        for i in range(Np):
            for j in range(Np):
                if j!=i:
                    m[i,j] = M_base/(2*(Np-1))
        
        theta_true.append([float(t['time']),[Ne0,m]])
        sample_scheme_byepoch.append(pop_sizes)

    return theta_true,sample_scheme_byepoch

#theta: the list of epochs that we want to simulate. Each entry is equal to one epoch; each entry has:
#  0: Starting time of the epoch
#  1: List with two items: Total Population size at start of epoch, and migration matrix
#    Migration Matrix: NxN (where N = Number of Populations, Np), Rate of migration between each population
#sample_nums: Array of population sizes, of length Np; the number of samples drawn from the population
#L: Length of the sequence we will be simulating
#r: Recombination rate, constant accross all populations
#mu: Mutation rate, constant accross all populations
#R: Number of replicates; msprime will run R simulations and return an iterator over all trees created
#Updated: Return list of ts_replicates; each entry will be the simulations for each epoch
def run_msprime_tskit(theta,sample_nums,L,r,mu,R):
    ts_rep_list = []
    ts_replicates = None
    
    Np = len(sample_nums)
#     print('samples to be drawn for populations: {0}'.format(sample_nums))
    init_pop_configs = [ms.PopulationConfiguration(sample_size=sample_nums[i], initial_size=theta[0][1][0][i]) for i in range(Np)]
    
    init_mig = theta[0][1][1]
    
    K = len(theta)  # K = number of epochs
    if K > 1:
        # There is more than one epoch, so must set the non-initial epochs as demographic events
        demo_events = []
        for k in range(1,K):
            t_k,theta_k = theta[k]
            Ne = theta_k[0]
            mig = theta_k[1]
            for i in range(Np):
                # Set the Ne
                demo_events.append(ms.PopulationParametersChange(population=i,time=t_k,initial_size=Ne[i]))

                # Set the migration rates
                for j in range(Np):
                    if j!=i:
                        demo_events.append(ms.MigrationRateChange(time=t_k,rate=mig[i,j],matrix_index=tuple([i,j])))
#         print(init_pop_configs)
        ts_replicates = ms.simulate(
            length=L,
            recombination_rate=r,
            population_configurations=init_pop_configs,
            migration_matrix = init_mig,
            demographic_events=demo_events,
            num_replicates=R,
            mutation_rate = mu
        )
    else:
        # There is only the initial epoch. 
        ts_replicates = ms.simulate(
            length=L,
            recombination_rate=r,
            population_configurations=init_pop_configs,
            migration_matrix = init_mig,
            num_replicates=R,
            mutation_rate = mu
        )
    return ts_replicates

def assign_genotype_index(samp_size,num_inds):
    ind_haps_dict = {}
    haps_used = []
    x = num_inds
#     x = int(samp_size/2)
    for n in range(x):
        curr_haps = []
        while (len(curr_haps) != 2):
            temp_seq_num = random.randint(0,(samp_size-1))
            if(temp_seq_num not in haps_used and temp_seq_num not in curr_haps):
                curr_haps.append(temp_seq_num)
                haps_used.append(temp_seq_num)
        ind_haps_dict[n] = curr_haps
    return ind_haps_dict

# def save_pheno_vcf(samp_size,seq_len,num_individuals,outname):
#     tree_sequence = msprime.simulate(sample_size=samp_size, Ne=1e4, length=seq_len, recombination_rate=2e-8,mutation_rate=2e-8) 
#     new_ids = []
#     for i in range(num_individuals):
#         new_ids.append(''.join(['ID',str(i)]))
        
#     with open('{0}.vcf'.format(outname), "w") as vcf_file:
#         tree_sequence.write_vcf(vcf_file, ploidy=2,individual_names=new_ids)

def estimate_pheno(genotypes,beta):
#     causal_pos = 0 #int(len(genotype[0])/2)
    full_phenovals = []
    for g in genotypes:
        try:
            c_al1 = float(g[0])
            c_al2 = float(g[1])
            full_phenovals.append((c_al1 + c_al2)*beta)
        except:
            print("Error!",g)
    return sum(full_phenovals)

def plot_phenodist(pheno_dict, num_inds,outname):
    pheno_df = DataFrame(pheno_dict.values(),index=pheno_dict.keys(),columns=['Pheno_value'])

    mu, std = norm.fit(pheno_df['Pheno_value'])

    pyplot.hist(pheno_df['Pheno_value'])

    xmin, xmax = pyplot.xlim()
    x = np.linspace(xmin, xmax, 100)
    p = (norm.pdf(x, mu, std))*(num_inds*2)
    pyplot.plot(x, p, 'k', linewidth=2)
    title = "Fit results: mu = %.2f,  std = %.2f" % (mu, std)
    pyplot.title(title)
    pyplot.ylabel('Number of Individuals in Bin')
    pyplot.xlabel('Phenotype Value')
    pyplot.savefig('{0}.phenodist.png'.format(outname))

def generate_betas(num_inds,dist_type='normal'):
    if(dist_type == 'normal'):
        dist = np.random.normal(0,0.1,num_inds)
    return dist


def write_phenofile(outname,pheno_dict,popid_dict=None):
    pheno_file = open('{0}.phenotypes'.format(outname),'w')
    if(popid_dict == None):
        new_ids = []
        for i in range(len(pheno_dict.items())):
            new_ids.append(''.join(['ID',str(i)]))
    else:
        new_ids = []
        for i,pop in popid_dict.items():
            new_ids.append(''.join(['POP',str(pop),'ID',str(i),]))
    for ind,p in pheno_dict.items():
        pheno_file.write('{0}\t{1}\n'.format(new_ids[ind],p))
    pheno_file.close()

def run_pheno_simulation(samp_size,seq_len,L,num_individuals,outname,beta,causal_var_id=1):
    genotype_index_byinds = assign_genotype_index(samp_size,num_individuals) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
    causalgenotypes_byind = {x:[] for x in range(num_individuals)}
    causalgenotypes_byrep = {x:[] for x in range(L)}  #Each repetition, add the genotype from that rep (as a tuple) to this dictionary. Then we can just iterate through the list of values to generate the final phenotype
    fullgenotypes_byrep = {x:[] for x in range(L)}
    causalpositions_byrep = {x:0 for x in range(L)}
    rep = 0
    while (rep < L):
        tree_sequence = msprime.simulate(sample_size=samp_size, Ne=1e4, length=seq_len, recombination_rate=2e-8,mutation_rate=2e-8) 
        curr_causal_var = []
        curr_causal_pos = ''
        curr_full_vars_posgeno_dict = {}
        for variant in tree_sequence.variants():
            curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
            if(variant.site.id == causal_var_id):
                curr_causal_var = list(variant.genotypes)
                curr_causal_pos = round(variant.site.position)
        if(len(curr_causal_var) != samp_size):
            print('no causal variants in rep {0}, redoing'.format(rep))
            rep -= 1
            continue

        causalpositions_byrep[rep] = curr_causal_pos
        curr_rep_genotypes = []
        for indiv,index in genotype_index_byinds.items():
            try:
                causalgenotypes_byind[indiv].append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
                curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
            except:
                print(indiv,index)
        causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

        curr_rep_fullgenos = {}
        for pos,geno in curr_full_vars_posgeno_dict.items():
            temp_fullgeno = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                except:
                    print(indiv,index)
            curr_rep_fullgenos[pos] = temp_fullgeno
        fullgenotypes_byrep[rep] = curr_rep_fullgenos
        rep += 1

    phenotypes_byinds = {x:0 for x in range(num_individuals)}
    beta_list = generate_betas(num_inds=num_individuals,dist_type=beta)
    for i in range(num_individuals):
        curr_beta = beta_list[i]
        phenotypes_byinds[i] = estimate_pheno(causalgenotypes_byind[i],curr_beta)

    plot_phenodist(phenotypes_byinds,num_individuals,outname)
    write_phenofile(outname,phenotypes_byinds)

    return causalpositions_byrep,fullgenotypes_byrep


    


def run_geno_simulation(samp_size,seq_len,L,num_individuals,causal_var_id=1):
    genotype_index_byinds = assign_genotype_index(samp_size,num_individuals) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
    causalgenotypes_byrep = {x:[] for x in range(L)} #Each repetition, add the genotype from that rep (as a tuple) to this dictionary. Then we can just iterate through the list of values to generate the final phenotype
    fullgenotypes_byrep = {x:[] for x in range(L)}
    causalpositions_byrep = {x:0 for x in range(L)}
    rep = 0
    while (rep < L):
        tree_sequence = msprime.simulate(sample_size=samp_size, Ne=1e4, length=seq_len, recombination_rate=2e-8,mutation_rate=2e-8) 
        num_vars = 0
        for variant in tree_sequence.variants():
            num_vars += 1
        if(num_vars == 0):
            print('no variants in rep {0}, redoing'.format(rep))
            rep = rep-1
            continue
        causal_var_id = random.randint(0,(num_vars-1))
        curr_causal_var = []
        curr_causal_pos = 0
        curr_full_vars_posgeno_dict = {}
        for variant in tree_sequence.variants():
            curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
            if(variant.site.id == causal_var_id):
                curr_causal_var = list(variant.genotypes)
                curr_causal_pos = round(variant.site.position)

        if(len(curr_causal_var) != samp_size):
            print('no causal variants in rep {0}, redoing'.format(rep))
            rep -= 1
            continue
        causalpositions_byrep[rep] = curr_causal_pos
        curr_rep_genotypes = []
        for indiv,index in genotype_index_byinds.items():
            try:
                curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
            except:
                print(indiv,index)
        causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

        curr_rep_fullgenos = {}
        for pos,geno in curr_full_vars_posgeno_dict.items():
            temp_fullgeno = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                except:
                    print(indiv,index)
            curr_rep_fullgenos[pos] = temp_fullgeno
        fullgenotypes_byrep[rep] = curr_rep_fullgenos

        rep += 1
    return causalpositions_byrep,fullgenotypes_byrep


def write_genovcf(full_geno_dict,causal_pos_dict,outname,seq_len,window_spacer=1000,popid_dict=None):
    use_diff_chrms = False
    if(window_spacer == 'chrm'):
        window_spacer = 0
        use_diff_chrms = True
    full_len = len(full_geno_dict)*(window_spacer+seq_len)
    header_string = '##fileformat=VCFv4.2 \n##source=tskit 0.2.2 \n##FILTER=<ID=PASS,Description="All filters passed"> \n##INFO=<ID=CS,Number=0,Type=Flag,Description="SNP Causal to Phenotype"> \n##contig=<ID=1,length={0}>\n##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype"> \n'.format(full_len)
    vcf_file = open('{0}.vcf'.format(outname),'w')
    vcf_file.write(header_string)
    vcf_file.write('#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t')
    if(popid_dict == None):
        new_ids = []
        for i in range(len(geno_dict[0][1])):
            curr_nid = ''.join(['ID',str(i)])
            new_ids.append(curr_nid)
            vcf_file.write('{0}\t'.format(curr_nid))
        vcf_file.write('\n')
    else:
        new_ids = []
        for i,pop in popid_dict.items():
            curr_nid = ''.join(['POP',str(pop),'ID',str(i),])
            new_ids.append(curr_nid)
            vcf_file.write('{0}\t'.format(curr_nid))
        vcf_file.write('\n')
    for rep,geno_dict in full_geno_dict.items():
        is_rep_causalsnp = False
        for pos,genos in geno_dict.items():
            try:
                if(use_diff_chrms == True):
                    curr_pos = (int(rep)*(window_spacer+seq_len))+pos
                    if(pos == causal_pos_dict[rep]):
                        is_rep_causalsnp = True
                        vcf_file.write('{0}\t{1}\t.\tA\tG\t.\tPASS\tCS\tGT\t'.format(rep,curr_pos))
                    else:
                        vcf_file.write('{0}\t{1}\t.\tA\tG\t.\tPASS\t.\tGT\t'.format(rep,curr_pos))
                    for g in genos:
                        vcf_file.write('{0}|{1}\t'.format(g[0],g[1]))
                    vcf_file.write('\n')
                else:
                    curr_pos = (int(rep)*(window_spacer+seq_len))+pos
                    if(pos == causal_pos_dict[rep]):
                        is_rep_causalsnp = True
                        vcf_file.write('1\t{0}\t.\tA\tG\t.\tPASS\tCS\tGT\t'.format(curr_pos))
                    else:
                        vcf_file.write('1\t{0}\t.\tA\tG\t.\tPASS\t.\tGT\t'.format(curr_pos))
                    for g in genos:
                        vcf_file.write('{0}|{1}\t'.format(g[0],g[1]))
                    vcf_file.write('\n')

            except:
                print(rep,genos)
        
def assign_pop_inds(pop_sizes):
    pop_assign = []  # row index = pop index. value = list of indices of samples assigned to each pop.
    j = 0
    for i in range(len(pop_sizes)):
        Ni = pop_sizes[i]
        indices = list(range(j,j+Ni))
        pop_assign.append(indices)
        j+=Ni
    return pop_assign   

def assign_popdict(pop_scheme):
    full_sampsize = sum(pop_scheme)
    popindex_byind = {x:0 for x in range(full_sampsize)}
    for pop,size in enumerate(pop_scheme):
        for x in range(size):
            popindex_byind[(x + (size*pop))] = pop
    return popindex_byind

# def get_indtopop_dict(genoind_bypops):
#     indpop_dict = {}
#     prev_pn = 0
#     for num,p in enumerate(genoind_bypops.items()):
#         for i,g in enumerate(p[1]):
#             indpop_dict[(prev_pn+i)] = p[0]
#         prev_pn += len(p[1])
#     return indpop_dict

def get_ind_genoindex_multipop(genoind_bypops):
    ind_genoindex_dict = {}
    prev_pn = 0
    for num,p in enumerate(genoind_bypops.items()):
        for i,g in enumerate(p[1]):
            ind_genoindex_dict[(prev_pn+i)] = g
        prev_pn += len(p[1])
    return ind_genoindex_dict

#Runs the phenotype-generating simulation, for multiple populations and multiple epochs
#Returns a 2 lists of dictionaries; per epoch. 
#    causalpos_byepoch: for each replicate in the epoch, contains the position that was used to calculate the phenotype. Used to indicate in the output vcf file which SNP is the causal one
#    genos_byepoch: for each replicate in each epoch, has a dictionary containing the genotypes for each person; each per
def run_pheno_simulation_multipops(theta,seq_len,reps,pop_schemes,r,mu,outname,beta='normal'):
    
    genos_byepoch = []
    causalpos_byepoch = []

    for epoch in range(len(theta)):
        print('Starting epoch {0} replicates'.format(epoch+1))

        pop_sizes = [(i*2) for i in pop_schemes[epoch]] # Num individuals simulated, equal to twice the number of individuals, since each person is diploid
        sample_scheme = [i for i in pop_schemes[epoch]] # Num samples drawn from each pop for likelihood
        full_sampsize = sum(sample_scheme)

        genotype_index_bypops = assign_genotype_index_multipop(sample_scheme,pop_sizes) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
        genotype_index_byinds = get_ind_genoindex_multipop(genotype_index_bypops)
        causalgenotypes_byrep = {x:[] for x in range(reps)}
        causalpositions_byrep = {x:0 for x in range(reps)}
        fullgenotypes_byrep = {x:[] for x in range(reps)}


        curr_theta = theta[:epoch+1]
        print('epoch {0} theta = {1}'.format(epoch,curr_theta))
        tsreps = run_msprime_tskit(curr_theta,pop_sizes,seq_len,r,mu,reps)
        # pdb.set_trace()
        print('replicate trees created; iterating through genotypes now')

        for rep,tree_sequence in enumerate(tsreps): 
            # pdb.set_trace()
            # print('starting replicate {0}'.format(rep))
            num_vars = 0
            for variant in tree_sequence.variants():
                num_vars += 1
            causal_var_id = random.randint(0,(num_vars-1))
            curr_causal_var = []
            curr_causal_pos = 0
            curr_full_vars_posgeno_dict = {}
            for variant in tree_sequence.variants():
                curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
                if(variant.site.id == causal_var_id):
                    curr_causal_var = list(variant.genotypes)
                    curr_causal_pos = round(variant.site.position)

            if(len(curr_causal_var) != (full_sampsize*2)):
                print('not enough causal variants in rep {0}'.format(rep))
                curr_causal_var = [0 for x in range((full_sampsize*2))]
                curr_full_vars_posgeno_dict[0] = [0 for x in range((full_sampsize*2))]
            causalpositions_byrep[rep] = curr_causal_pos

            curr_rep_genotypes = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
                except:
                    print(indiv,index,len(curr_causal_var))
            causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

            curr_rep_fullgenos = {}
            for pos,geno in curr_full_vars_posgeno_dict.items():
                temp_fullgeno = []
                for indiv,index in genotype_index_byinds.items():
                    try:
                        temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                    except:
                        print(rep,indiv,index,len(geno))
                curr_rep_fullgenos[pos] = temp_fullgeno
            fullgenotypes_byrep[rep] = curr_rep_fullgenos
        print('finished iterating through trees, starting the phenotype calculations')
        causalgenotypes_byind = {x:[] for x in range(full_sampsize)}
        for pos,genos in causalgenotypes_byrep.items():
            for num,g in enumerate(genos[1]):
                causalgenotypes_byind[num].append(g)
        beta = 'normal'
        phenotypes_byinds = {x:0 for x in range(full_sampsize)}
        beta_list = generate_betas(num_inds=full_sampsize,dist_type=beta)
        for i in range(full_sampsize):
            curr_beta = beta_list[i]
            phenotypes_byinds[i] = estimate_pheno(causalgenotypes_byind[i],curr_beta)
        # phenos_byepoch.append(phenotypes_byinds)
        write_phenofile('{0}.epoch{1}'.format(outname,epoch),phenotypes_byinds)
        
        genos_byepoch.append(fullgenotypes_byrep)
        causalpos_byepoch.append(causalpositions_byrep)
    
    return causalpos_byepoch,genos_byepoch


if __name__ == "__main__":
    args = parser.parse_args()
    if(args.beta_type is None):
        beta = "normal"
    else:
        beta = args.beta_type

    if(type(args.window) == str):
        window = 'chrm'
    else:
        window = int(args.window)

    # popindex_byind = {x:0 for x in range(full_sampsize)}
    # for pop,size in enumerate(sample_scheme):
    #     for x in range(size):
    #         popindex_byind[(x + (size*pop))] = pop    

    if(args.input_file is None):
        cpos_pheno_byinds,pgenos_byinds = run_pheno_simulation(int(args.samp_size),int(args.seq_len),int(args.L),int(args.num_individuals),args.out_name,beta)
        write_genovcf(pgenos_byinds,cpos_pheno_byinds,'{0}.pheno'.format(args.out_name),int(args.num_individuals),int(args.seq_len),window)

        cpos_geno_byind,genos_byinds = run_geno_simulation(int(args.samp_size),int(args.seq_len),int(args.L),int(args.num_individuals))
        write_genovcf(genos_byinds,cpos_geno_byind,'{0}.geno'.format(args.out_name),int(args.num_individuals),int(args.seq_len),window)
    else:
        
        theta,sample_schemes = read_input_file(args.input_file)
        
        cpos_pheno_byinds,pgenos_byinds = run_pheno_simulation_multipops(theta,int(args.seq_len),int(args.L),sample_schemes,float(args.recombination_rate),float(args.mutation_rate),args.out_name,beta)
        for epoch,pg in enumerate(pgenos_byinds):
            curr_popid_dict = assign_popdict(sample_schemes[epoch])
            write_genovcf(pg,cpos_pheno_byinds[epoch],'{0}.epoch{1}.pheno'.format(args.out_name,epoch),int(args.seq_len),window,curr_popid_dict)

        # cpos_geno_byind,genos_byinds = run_geno_simulation(int(args.samp_size),int(args.seq_len),int(args.L),int(args.num_individuals))
        # write_genovcf(genos_byinds,cpos_geno_byind,'{0}.geno'.format(args.out_name),int(args.num_individuals),int(args.seq_len),window)
    














