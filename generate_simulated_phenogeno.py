import sys
from pandas import *
import numpy as np
import matplotlib
from matplotlib import pyplot
import itertools as it
import matplotlib.backends.backend_pdf
import math
from matplotlib.pyplot import cm
from dateutil import parser
import scipy
from scipy.stats import mstats
import re
import matplotlib.dates as mdates
import datetime
import msprime as ms
import random
from scipy.stats import norm
from argparse import ArgumentParser
# import pdb

parser = ArgumentParser()
parser.add_argument("-r", "--repetitions", dest="L",
                    help="number of simulated genotypes to run, corrisponding to the number of causal variants")
parser.add_argument("-s", "--samplesize", dest="samp_size",
                    help="number of genotypes that will be simulated for each run")
parser.add_argument("-w", "--window", dest="window",
                    help="window size to use as a spacer between the SNPs generated by the simulation. If the input is not a number, each SNP generated will be on its own chromosome (number = replicate)")
parser.add_argument("-n", "--num_inds", dest="num_individuals",
                    help="number of individuals that will be used to create the genotypes and phenotypes")
parser.add_argument("-l", "--sequence_length", dest="seq_len",
                    help="length of the sequence that will be simulated; the only variant that will be used from this is the causal one")
parser.add_argument("-b", "--beta", dest="beta_type",
                    help="string keyword that corrisponds to how we want to assign the beta value for the phenotype (ie constant means the beta value will be the same for all causal variants)")
parser.add_argument("-o", "--out", dest="out_name",
                    help="name of the file to be saved, the files <out_name>.phenodist.png, <out_name>.pheno.vcf, <out_name>.geno.vcf and <out_name>.phenotypes  will be created")
parser.add_argument("-f", "--file", dest="input_file",
                    help="the name of the file that contains the epochs that we will be simulating. The file format is described in the read_input_file function description.")
parser.add_argument("-m", "--mutrate", dest="mutation_rate",
                    help="rate of mutation to use for simulation.")
parser.add_argument("-c", "--recombrate", dest="recombination_rate",
                    help="rate of recombination to use for simulation.")
parser.add_argument("-p", "--phenotype", dest="make_phenotype",action='store_true',
                    help="provide this flag if you want the script to generate a phenotype file")
parser.add_argument("-a", "--outofafrica", dest="ooafrica",action='store_true',
                    help="provide this flag if you want the script to use the outofafrica_model_parameters function as the initial demographic events")
parser.add_argument("-g", "--recombmap", dest="recomb_map",
                    help="file containing the recombination map for a single chromosome, from hapmap")
parser.add_argument("-e", "--epochpopfile", dest="epochpops_file",
                    help="file containing the epochs and populations in them that you want to generate a vcf file for. If not provided, assume all valid epochs should be saved.")

# assign_genotype_index((num_individuals*num_pops),(num_individuals*num_pops)*2)
#Take the genotypes that are simulated, and assign two of the indexes to each individual.
#samp_sizes: number of individuals that you want to sample, an array of length P
#pop_sizes: Total number of genotypes in each population that you are simulating, an array of length P. Each entry must be at least double the entry in samp_sizes
def assign_genotype_index_multipop(samp_sizes,pop_sizes):
    for i,s in enumerate(samp_sizes):
        if(pop_sizes[i] < (2*s)):
            print('number of genotypes in population {0} is not at least double the number of individuals you are simulating! {1} < {2}'.format(i,pop_sizes[i],(s*2)))
            return -1
    ind_haps_dict_bypop = {x:[] for x in range(len(pop_sizes))}
    x = sum(pop_sizes)
    prev_indstart = 0
    for n,p in enumerate(pop_sizes):
        num_inds_tosample = samp_sizes[n]
        curr_popinds = []
        for x in range(p):
            curr_popinds.append(x + prev_indstart)
        
        popinds_used = []
        temp_popinds = []
        for x in range(num_inds_tosample):
            curr_haps = []
            while (len(curr_haps) != 2):
                temp_seq_num = random.randint(min(curr_popinds),max(curr_popinds))
                if(temp_seq_num not in popinds_used and temp_seq_num not in curr_haps):
                    curr_haps.append(temp_seq_num)
                    popinds_used.append(temp_seq_num)
            temp_popinds.append(curr_haps)
        ind_haps_dict_bypop[n] = temp_popinds
        prev_indstart += p
    return ind_haps_dict_bypop

#Reads in a file that has the epochs that we want to simulate. The file needs to be in a tab-seperated file, with a header.
#The file needs to be named <filename>.epochs
#Each line after the header represents 1 epoch. Necessary columns include:
#time: starting time of the epoch
#init_pops: the number of people in each population that will be simulated
#num_pops: the number of different populations that we want to simulate
#migration_rate: the rate of migration for the epoch. This is only necessary if you want to 
def read_input_file(filename):
    input_df = read_csv('{0}.epochs'.format(filename),sep='\t')
    num_theta = len(input_df)
    theta_true = []
    sample_scheme_byepoch = []
    migmat_fromfile = None
    try:
        mm_file = '{0}.migration_matrix'.format(filename)
        migmat_fromfile = get_input_migrationmatrix(filename,num_theta)
    except:
        pass
    # Set the demographic model parameters (theta)...
    for epoch,t in input_df.iterrows():
        Np = len(t['pop_scheme'].split(','))               # Num pops
        pop_sizes = [int(x) for x in t['pop_scheme'].split(',')]    # Num of samples per population in the observed data
        sample_scheme = [int(x) for x in t['pop_scheme'].split(',')]   # Num samples drawn from each pop for likelihood

        # pop sizes
        if(migmat_fromfile is None):
            N_base = 12300    # Number of diploids in the population; based on the N_AF from the tutorial Out_Of_Africa model
            Ne0 = np.ones(Np)*N_base
            # Set migration rates
            M_base = float(t['migration_rate'])
            m = np.zeros((Np,Np))
            for i in range(Np):
                for j in range(Np):
                    if j!=i:
                        m[i,j] = M_base/(2*(Np-1))
            theta_true.append([float(t['time']),[Ne0,m]])
        else:
            theta_true.append([float(t['time']),migmat_fromfile[epoch]])
        sample_scheme_byepoch.append(pop_sizes)

    return theta_true,sample_scheme_byepoch


#Reads in a file that has the epochs that we want to simulate. The file needs to be in a tab-seperated file, with a line per epoch, each one followed by a migration matrix outlining the migration values for each population pair
#Each line that indicates an epoch should start with a '#' symbol, followed immediately by the time of the start of the epoch, then a tab, then the population sizes seperated by commas (for example: 4,4,5 for 3 populations of that number of individuals)
#Following the line with the time/population sizes, the migration matrix which is of size NxN, where N=number of populations. The diagonal of the matrix should be zeros.
#   filename (str): name of the input file to read
#returns:
#   theta_true: description can be found in the run_msprime_tskit comment
#   sample_scheme_byepoch: a list of the population sizes for each epoch
def read_input_file_full(filename):
    infile = open(filename,'r')
    theta_true = []
    sample_scheme_byepoch = []
    curr_epoch = -1
    migmats_byepoch = {}
    times_byepoch = []
    curr_epochtype = ''
    massmigs_byepoch = {}
    demoevs_byepoch = {}
    ooafrica_sampscheme = []
    for line in infile:
        if(line[0] == '#'):
            curr_epoch += 1
            cline = line.split('\n')[0][1:].split('\t')
            print(cline)
            curr_epochtype = cline[0]
            if(curr_epochtype == 'ooafrica'):
                curr_popscheme = cline[1]
                curr_epoch -= 1
                ooafrica_sampscheme = [int(x) for x in curr_popscheme.split(',')]    # Num of samples per population in the observed data
            else:
                curr_time = cline[1]
                times_byepoch.append(float(curr_time))
                curr_popscheme = cline[2]
                pop_sizes = [int(x) for x in curr_popscheme.split(',')]    # Num of samples per population in the observed data
                sample_scheme_byepoch.append(pop_sizes)
        else:
            curr_mm = [float(f) for f in line.split('\n')[0].split('\t')]
            if(curr_epoch not in demoevs_byepoch.keys()):
                demoevs_byepoch[curr_epoch] = [curr_epochtype]
            demoevs_byepoch[curr_epoch].append(curr_mm)
    
    # pop sizes
    N_base = 14474    # Number of diploids in the population; based on the N_AF from the tutorial Out_Of_Africa model
    for e in range(len(sample_scheme_byepoch)):
        Ne0 = np.ones(len(sample_scheme_byepoch[e]))*N_base
        theta_true.append([demoevs_byepoch[e][0],times_byepoch[e],[Ne0,np.array(demoevs_byepoch[e][1:])]])

    if(args.ooafrica):
        theta_true.insert(0,['ooafrica',ooafrica_sampscheme,[]])
        sample_scheme_byepoch.insert(0,ooafrica_sampscheme)
    infile.close()
    return theta_true,sample_scheme_byepoch

#Runs the msprime simulate function, taking into account the 
#theta: the list of epochs that we want to simulate. Each entry is equal to one epoch; each entry has:
#  0: Starting time of the epoch
#  1: List with two items: Total Population size at start of epoch, and migration matrix
#    Migration Matrix: NxN (where N = Number of Populations, Np), Rate of migration between each population
#sample_nums: Array of population sizes, of length Np; the number of samples drawn from the population
#L: Length of the sequence we will be simulating
#r: Recombination rate, constant accross all populations
#mu: Mutation rate, constant accross all populations
#R: Number of replicates; msprime will run R simulations and return an iterator over all trees created
#Updated: Return list of ts_replicates; each entry will be the simulations for each epoch
def run_msprime_tskit(theta,sample_nums,L,r,mu,R,outname=None,outname_epoch=None,recomb_map=None):
    ts_replicates = None
    Np = len(sample_nums)
    demo_events = [] #This will be a list of demographic events. It must be ordered by time (ascending), or msprime will throw an error

    if(theta[0][0] == 'ooafrica'): #If the user wants the out-of-africa model to be used as the initial events for their simulation(s), the -a flag must be used when calling the script, and
                                    #the first element in the input file must be ooafrica along with the population sizes to be drawn/recorded in this epoch
        init_pop_configs, init_mig, demo_events = outofafrica_model_parameters(sample_nums)
        print('first epoch is ooafrica; the initial migration matrix is: {0}'.format(init_mig))
    else: #If the out-of-africa model is not used, we either are looking at a mrate (migration matrix) or a mass (mass migration) event as the initial epoch
        init_pop_configs = [ms.PopulationConfiguration(sample_size=sample_nums[i], initial_size=theta[0][2][0][i]) for i in range(Np)]
        
        if(theta[0][0] == 'mrate'):
            init_mig = theta[0][2][1]
        elif(theta[0][0] == 'mass'):
            init_mig = None
            for m in theta[0][2][1]:
                demo_events.append(ms.MassMigration(time=theta[0][1], source=m[0], destination=m[1], proportion=m[2]))

    K = len(theta)  # K = number of epochs
    if K > 1:
        # There is more than one epoch, so must set the non-initial epochs as demographic events
        for k in range(1,K):
            theta_type,t_k,theta_k = theta[k] #theta_type will be one of the three types indicated; t_k is the time that the event occurs, theta_k is the info about the migmatrix or massmig event, or ooafrica this value is not used
            if(theta_type == 'mrate'):
                Ne = theta_k[0] #effective population size, right now equal to the N_AF value from the out-of-africa model (14474)
                mig = theta_k[1] #migration matrix, size NxN where N is the number of populations
                for i in range(Np):
                    # Set the Ne
                    if(args.ooafrica and t_k <= 920): #If the out-of-africa model is being used as the initial events, we need to make sure that we add this event to the demo_events list before the time of the ooafrica events (920 generations)
                        demo_events.insert(0,ms.PopulationParametersChange(population=i,time=t_k,initial_size=Ne[i]))
                    else: #Otherwise, just add it to the list of demographic events
                        demo_events.append(ms.PopulationParametersChange(population=i,time=t_k,initial_size=Ne[i]))
                    # Set the migration rates
                    for j in range(Np):
                        if j!=i:
                            if(args.ooafrica and t_k <= 920):
                                demo_events.insert(0,ms.MigrationRateChange(time=t_k,rate=mig[i,j],matrix_index=tuple([i,j])))
                            else:
                                demo_events.append(ms.MigrationRateChange(time=t_k,rate=mig[i,j],matrix_index=tuple([i,j])))
            elif(theta_type == 'mass'):
                Ne = theta_k[0]
                massmig = theta_k[1] #Info about the mass migration event
                for m in massmig:
                    if(args.ooafrica and t_k <= 920):
                        demo_events.insert(0,ms.MassMigration(time=t_k, source=m[0], destination=m[1], proportion=m[2]))
                    else:
                        demo_events.append(ms.MassMigration(time=t_k, source=m[0], destination=m[1], proportion=m[2]))
            elif(theta_type == 'ooafrica'):
                ooa_pop_configs, ooa_mig, ooa_demoevents = outofafrica_model_parameters(theta[k][1]) #This function returns these 3 values, so we just need to add the demographic events to the list
                for d in ooa_demoevents:
                    demo_events.append(d)
            else:
                print('Epoch events should only be "mass", "mrate", or "ooafrica"!')
                return -1
        if(recomb_map is None):
            ts_replicates = ms.simulate(
                length=L,
                recombination_rate=r,
                population_configurations=init_pop_configs,
                migration_matrix = init_mig,
                demographic_events=demo_events,
                num_replicates=R,
                mutation_rate = mu
            )
        else:
            ts_replicates = ms.simulate(
                recombination_map = ms.RecombinationMap.read_hapmap(recomb_map),
                population_configurations=init_pop_configs,
                migration_matrix = init_mig,
                demographic_events=demo_events,
                num_replicates=R,
                mutation_rate = mu)
    else:
        print('there is only one epoch, starting now using theta {0}'.format(theta))
        # There is only the initial epoch. 
        if(init_mig is None): #If the first epoch event is a mass migration event, and the out-of-africa is not provided, then there's no migration matrix to provide
            if(recomb_map is None):
                ts_replicates = ms.simulate(
                length=L,
                recombination_rate=r,
                population_configurations=init_pop_configs,
                demographic_events = demo_events,
                num_replicates=R,
                mutation_rate = mu,
                )
            else:
                ts_replicates = ms.simulate(
                # length=L,
                recombination_map = ms.RecombinationMap.read_hapmap(recomb_map),
                population_configurations=init_pop_configs,
                demographic_events = demo_events,
                num_replicates=R,
                mutation_rate = mu,
                )
        else:
            if(len(demo_events) > 0):
                if(recomb_map is None):
                    ts_replicates = ms.simulate(
                    length=L,
                    recombination_rate=r,
                    population_configurations=init_pop_configs,
                    demographic_events = demo_events,
                    migration_matrix = init_mig,
                    num_replicates=R,
                    mutation_rate = mu
                    )
                else:
                    ts_replicates = ms.simulate(
                    recombination_map = ms.RecombinationMap.read_hapmap(recomb_map),
                    population_configurations=init_pop_configs,
                    demographic_events = demo_events,
                    migration_matrix = init_mig,
                    num_replicates=R,
                    mutation_rate = mu
                    )
            else:
                if(recomb_map is None):
                    ts_replicates = ms.simulate(
                        length=L,
                        recombination_rate=r,
                        population_configurations=init_pop_configs,
                        migration_matrix = init_mig,
                        num_replicates=R,
                        mutation_rate = mu
                    )
                else:
                    ts_replicates = ms.simulate(
                        recombination_map = ms.RecombinationMap.read_hapmap(recomb_map),
                        population_configurations=init_pop_configs,
                        migration_matrix = init_mig,
                        num_replicates=R,
                        mutation_rate = mu
                    )
    if(demo_events != None): #If there are any demographic events, make and save the DemographyDebugger so that the user can verify that the events occur as they wanted
        dp = ms.DemographyDebugger(
            population_configurations=init_pop_configs,
            migration_matrix=init_mig,
            demographic_events=demo_events)
        if(outname == None):
            print('Demography History for epoch {0}'.format(outname_epoch))
            dp.print_history(output=sys.stderr)
        else:
            outfile = open('{0}.epoch{1}.demohistory'.format(outname,outname_epoch),'w')
            dp.print_history(output=outfile)
            outfile.close()
    return ts_replicates


#Given a list of indexes to draw from and a number of individuals to draw, returns a randomly assigned list of 2 indexes per person
#This is used to create the haplotypes from single population
#    samp_size: list of the indexes that are available, and will be distributed to the individuals. Should be >=(2*num_inds)
#    num_inds: number of people that we want to assign indexes to. Each individual will have 2 indexes at the end
#returns ind_haps_dict: a dictionary. The keys are the individuals (a number for each), and the values are tuples where each number corrisponds to a position in the genotype list.
def assign_genotype_index(samp_size,num_inds):
    ind_haps_dict = {}
    haps_used = []
    for n in range(num_inds):
        curr_haps = []
        while (len(curr_haps) != 2):
            temp_seq_num = random.randint(0,(samp_size-1))
            if(temp_seq_num not in haps_used and temp_seq_num not in curr_haps):
                curr_haps.append(temp_seq_num)
                haps_used.append(temp_seq_num)
        ind_haps_dict[n] = curr_haps
    return ind_haps_dict


#Returns a phenotype value for the indivudal with the genotypes provieded; the sum of all the causal genotypes multiplied by the beta value
#    genotypes: list of tuples, where the tuples contain values of 0 or 1. These tuples are each the genotype for a signle individual from the causal SNP in each replicate.
#    beta: a float, representing the genetic component for the individual. Drawn from a distribution of values, but this could be altered as needed.
def estimate_pheno(genotypes,betas_byrep):
    full_phenovals = []
    for rep,g in enumerate(genotypes):
        try:
            c_al1 = float(g[0])
            c_al2 = float(g[1])
            full_phenovals.append((c_al1 + c_al2)*betas_byrep[rep])
        except:
            print("Error!",g)
    return sum(full_phenovals)

#Plots the distribution of phenotype values for all the individuals as a histogram, as well as a line representing a normal distribution over those bins, for verification
#  x-axis is the phenotype value, and the y-axis is the number of individuals in the bin
#    pheno_dict: dictionary of the phenotypes for the individuals. Keys are the individuals (as sequential integers), values are phenotype for that individual (as a float)
#    outname: the name of the file to save the plot as, in the format of <outname>.phenodist.png
def plot_phenodist(pheno_dict,outname):
    pheno_df = DataFrame(pheno_dict.values(),index=pheno_dict.keys(),columns=['Pheno_value'])

    mu, std = norm.fit(pheno_df['Pheno_value'])

    pyplot.hist(pheno_df['Pheno_value'])

    xmin, xmax = pyplot.xlim()
    x = np.linspace(xmin, xmax, 100)
    p = (norm.pdf(x, mu, std))*(len(pheno_dict)*2)
    pyplot.plot(x, p, 'k', linewidth=2)
    title = "Fit results: mu = %.2f,  std = %.2f" % (mu, std)
    pyplot.title(title)
    pyplot.ylabel('Number of Individuals in Bin')
    pyplot.xlabel('Phenotype Value')
    pyplot.savefig('{0}.phenodist.png'.format(outname))

#Get a distribution of values to use as betas for the phenotype calculation
#  right now, it only has one kind of distribution that it can generate, but in the future we can add different kinds of distributions to generate
#    num_inds (int): number of individuals, the distribution will generate this number of values.
#returns dist: an array of length <num_inds>, each position corrisponds to the beta for the individual with that number as their ID.
def generate_betas(num_inds,dist_type='normal'):
    if(dist_type == 'normal'):
        dist = np.random.normal(0,0.1,num_inds)
    return dist

#Saves the phenotype file. It is a tab-seperated file with 2 columns; the first column is the ID of the individual, and the second column is the phenotype value for that individual
#  IDs are converted from a single int into ID<id_num> for compliance with plink id restrictions. If there are multiple populations, it will be converted to POP<pop_num>ID<id_num>
#    outname: name of the file that it will be saved as, <outname>.phenotypes
#    pheno_dict: dictionary of phenotype values per individual. Keys are the individual ID number, and values are the phenotype vaule (a float)
#    popid_dict: dictionary of the individual to their population number. Keys are the individual ID number, and the value is the population id that they belong to (int). If it is not
#                provided, then there is only one population and this variable is ignored.
def write_phenofile(outname,pheno_dict,popid_dict=None):
    pheno_file = open('{0}.phenotypes'.format(outname),'w')
    if(popid_dict == None):
        new_ids = []
        for i in range(len(pheno_dict.items())):
            new_ids.append(''.join(['ID',str(i)]))
    else:
        new_ids = []
        for i,pop in popid_dict.items():
            new_ids.append(''.join(['POP',str(pop),'ID',str(i),]))
    for ind,p in pheno_dict.items():
        pheno_file.write('{0}\t{1}\n'.format(new_ids[ind],p))
    pheno_file.close()

#Runs the msprime simulation that generates phenotypes, as well as saves the genotypes that were used to create that phenotypes as a vcf file. 
#  This function is only used if there is a single population and only one time period.
#    samp_size (int): number of genomes to simulate, should be at least double the num_individuals
#    seq_len (int): length of the sequence that will be simulated
#    L (int): number of replicates to use in generating the simulation
#    num_individuals (int): number of people that we want to simulate phenotypes/genotypes for, 2 genomes per person
#    outname: name of the file that will be saved
#    beta: type of distribution that will be used to pull beta values from
#    causal_var_id: the id of the variant that will be used as the causal variant. Defaults to 1, meaning the first variant will be counted as the causal variants.
def run_pheno_simulation(samp_size,seq_len,L,num_individuals,outname,beta,causal_var_id=1):
    genotype_index_byinds = assign_genotype_index(samp_size,num_individuals) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
    causalgenotypes_byind = {x:[] for x in range(num_individuals)} #Stores the genotypes, as a list of tuples (each tuple is (0,0), (1,1), (1,0), or (0,1)), for each individual. Keys are the individual ID, values are the genotype lists
    causalgenotypes_byrep = {x:[] for x in range(L)}  #Each repetition, add the genotype from that rep (as a tuple) to this dictionary. Then we can just iterate through the list of values to generate the final phenotype
    fullgenotypes_byrep = {x:{} for x in range(L)} #Store the full list of genotypes of all individuals for each variant position for each repetition. Keys are repetition number, values are a dictionary of the variants created in that replication.
    causalpositions_byrep = {x:0 for x in range(L)} #A dictionary of the positions that we consider as the causal snp in the repetition. Keys are the repetition number, value is the position of the variant (an int)
    rep = 0
    while (rep < L):
        tree_sequence = msprime.simulate(sample_size=samp_size, Ne=1e4, length=seq_len, recombination_rate=2e-8,mutation_rate=2e-8) 
        curr_causal_var = []
        curr_causal_pos = ''
        curr_full_vars_posgeno_dict = {}
        for variant in tree_sequence.variants():
            curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
            if(variant.site.id == causal_var_id):
                curr_causal_var = list(variant.genotypes)
                curr_causal_pos = round(variant.site.position)
        if(len(curr_causal_var) != samp_size):
            print('no causal variants in rep {0}, redoing'.format(rep))
            rep -= 1
            continue

        causalpositions_byrep[rep] = curr_causal_pos
        curr_rep_genotypes = []
        for indiv,index in genotype_index_byinds.items():
            try:
                causalgenotypes_byind[indiv].append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
                curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
            except:
                print(indiv,index)
        causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

        curr_rep_fullgenos = {}
        for pos,geno in curr_full_vars_posgeno_dict.items():
            temp_fullgeno = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                except:
                    print(indiv,index)
            curr_rep_fullgenos[pos] = temp_fullgeno
        fullgenotypes_byrep[rep] = curr_rep_fullgenos
        rep += 1

    phenotypes_byinds = {x:0 for x in range(num_individuals)}
    beta_list = generate_betas(num_inds=num_individuals,dist_type=beta)
    for i in range(num_individuals):
        curr_beta = beta_list[i]
        phenotypes_byinds[i] = estimate_pheno(causalgenotypes_byind[i],curr_beta)

    plot_phenodist(phenotypes_byinds,num_individuals,outname)
    write_phenofile(outname,phenotypes_byinds)

    return causalpositions_byrep,fullgenotypes_byrep


    

#Runs the msprime simulation that generates genotypes and saves them as a vcf file. 
#  This function is only used if there is a single population and only one time period.
#    samp_size (int): number of genomes to simulate, should be at least double the num_individuals
#    seq_len (int): length of the sequence that will be simulated
#    L (int): number of replicates to use in generating the simulation
#    num_individuals (int): number of people that we want to simulate phenotypes/genotypes for, 2 genomes per person
#    outname: name of the file that will be saved
#    causal_var_id: the id of the variant that will be used as the causal variant. Defaults to 1, meaning the first variant will be counted as the causal variants.
def run_geno_simulation(samp_size,seq_len,L,num_individuals,chrm=1,causal_var_id=1):
    genotype_index_byinds = assign_genotype_index(samp_size,num_individuals) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
    causalgenotypes_byrep = {x:[] for x in range(L)} #Each repetition, add the genotype from that rep (as a tuple) to this dictionary. Then we can just iterate through the list of values to generate the final phenotype
    fullgenotypes_byrep = {x:[] for x in range(L)}
    causalpositions_byrep = {x:0 for x in range(L)}
    rep = 0
    while (rep < L):
        tree_sequence = msprime.simulate(sample_size=samp_size, Ne=1e4, length=seq_len, recombination_rate=2e-8,mutation_rate=2e-8) 
        num_vars = 0
        for variant in tree_sequence.variants():
            num_vars += 1
        if(num_vars == 0):
            print('no variants in rep {0}, redoing'.format(rep))
            rep = rep-1
            continue
        causal_var_id = random.randint(0,(num_vars-1))
        curr_causal_var = []
        curr_causal_pos = 0
        curr_full_vars_posgeno_dict = {}
        for variant in tree_sequence.variants():
            curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
            if(variant.site.id == causal_var_id):
                curr_causal_var = list(variant.genotypes)
                curr_causal_pos = round(variant.site.position)

        if(len(curr_causal_var) != samp_size):
            print('no causal variants in rep {0}, redoing'.format(rep))
            rep -= 1
            continue
        causalpositions_byrep[rep] = curr_causal_pos
        curr_rep_genotypes = []
        for indiv,index in genotype_index_byinds.items():
            try:
                curr_rep_genotypes.append((curr_causal_var[index[0]],curr_causal_var[index[1]]))
            except:
                print(indiv,index)
        causalgenotypes_byrep[rep] = [curr_causal_pos,curr_rep_genotypes]

        curr_rep_fullgenos = {}
        for pos,geno in curr_full_vars_posgeno_dict.items():
            temp_fullgeno = []
            for indiv,index in genotype_index_byinds.items():
                try:
                    temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                except:
                    print(indiv,index)
            curr_rep_fullgenos[pos] = temp_fullgeno
        fullgenotypes_byrep[rep] = curr_rep_fullgenos

        rep += 1
    return causalpositions_byrep,fullgenotypes_byrep


#Writes a genotype to a vcf file. As a default, the variants will be outputted as being on a single chromosome (chrm 1) and having a position equal to their simulated position plus a padding of (window_spacer+seq_len)*(replicate number) 
#    full_geno_dict: dictionary containing the full genotypes for a simulation, for all replicates. Keys are the replicate number, values are dictionaries of positions to genotypes. The fullgenotypes_byrep is what is being passed here.
#    causal_pos_dict: dictionary with the causal variant position for each replicate. Keys are the replicate number, value is an int representing the variant that is the causal SNP.
#    outname: name of the vcf file that will be saved, formatted as <outname>.vcf
#    seq_len: length of the sequence that was simulated. This is used to determine the full length of the simulated vcf, for the header, and to properly determine the position of each SNP as we record it
#    window_spacer: length of bases that will be used to pad the positions between each replicate. Future functionality will allow the user to specify that each replicate will be on their own chromosome (number = replicate number), rather than have a window spacer.
#    popid_dict: a dictionary that is only passed if the simulation has multiple populations. Keys are the individual ID, values are the population ID that they belong to.
#        This will be used to write the ID to the VCF, formatted as POP<population_id>ID<individual_id>. If this is not passed to this function, the format of the ID is ID<individual_id>
def write_genovcf(reps,outname,num_inds,seq_len,epoch,window_spacer=1000,popid_dict=None,pop_num=None,chrm=4):
    use_diff_chrms = False
    if(window_spacer == 'chrm'):
        window_spacer = 0
        use_diff_chrms = True
    full_len = reps*(window_spacer+seq_len)
    header_string = '##fileformat=VCFv4.2\n##source=tskit 0.2.2\n##FILTER=<ID=PASS,Description="All filters passed">\n##INFO=<ID=CS,Number=0,Type=Flag,Description="SNP Causal to Phenotype">\n##INFO=<ID=RP,Number=1,Type=Integer,Description="Repetition number">\n##contig=<ID={1},length={0}>\n##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">\n'.format(full_len,chrm)
    if(pop_num is None):
        vcf_file = open('{0}.epoch{1}.vcf'.format(outname,epoch),'w')
    else:
        vcf_file = open('{0}.epoch{1}.population{2}.vcf'.format(outname,epoch,pop_num),'w')
    vcf_file.write(header_string)
    vcf_file.write('#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT')
    if(popid_dict == None):
        new_ids = []
        for i in range(num_inds):
            curr_nid = ''.join(['ID',str(i)])
            new_ids.append(curr_nid)
            vcf_file.write('\t{0}'.format(curr_nid))
        vcf_file.write('\n')
    else:
        new_ids = []
        for i,pop in popid_dict.items():
            curr_nid = ''.join(['POP',str(pop),'ID',str(i),])
            new_ids.append(curr_nid)
            vcf_file.write('\t{0}'.format(curr_nid))
        vcf_file.write('\n')
    print('starting to write genotypes; use_diff_chrms is {0}'.format(use_diff_chrms))
    for rep in range(reps):
        geno_dict,causal_pos = get_genotypedict_fromfile(outname,epoch,rep)
        is_rep_causalsnp = False
        for pos,genos in geno_dict.items():
            try:
                if(use_diff_chrms == True):
                    # curr_pos = (int(rep)*(window_spacer+seq_len))+pos
                    curr_pos=pos
                    if(pos == causal_pos):
                        is_rep_causalsnp = True
                        vcf_file.write('{0}\t{1}\t.\tA\tG\t.\tPASS\tRP={0};CS\tGT'.format(rep,curr_pos))
                    else:
                        vcf_file.write('{0}\t{1}\t.\tA\tG\t.\tPASS\tRP={0}\tGT'.format(rep,curr_pos))
                    for g in genos:
                        vcf_file.write('\t{0}|{1}'.format(g[0],g[1]))
                    vcf_file.write('\n')
                else:
                    # curr_pos = (int(rep)*(window_spacer+seq_len))+pos
                    curr_pos=pos
                    if(pos == causal_pos):
                        is_rep_causalsnp = True
                        vcf_file.write('{2}\t{0}\t.\tA\tG\t.\tPASS\tRP={1};CS\tGT'.format(curr_pos,rep,chrm))
                    else:
                        vcf_file.write('{2}\t{0}\t.\tA\tG\t.\tPASS\tRP={1}\tGT'.format(curr_pos,rep,chrm))
                    for g in genos:
                        vcf_file.write('\t{0}|{1}'.format(g[0],g[1]))
                    vcf_file.write('\n')

            except:
                print(rep,genos)
    vcf_file.close()
        
#Assigns individual ID numbers to the populations. IDs will be assined sequentially, so if pop 0 has a size of 4, IDs 0,1,2,3 will be assigned to pop 0.
#    pop_sizes: list of ints, where each int is the population size of the population corrisponding to its position in the list
#returns pop_assign: a list of lists; each list has the individual ID numbers assigned to the population corrisponding to the position in this list
def assign_pop_inds(pop_sizes):
    pop_assign = []  # row index = pop index. value = list of indices of samples assigned to each pop.
    j = 0
    for i in range(len(pop_sizes)):
        Ni = pop_sizes[i]
        indices = list(range(j,j+Ni))
        pop_assign.append(indices)
        j+=Ni
    return pop_assign   

#Assigns each individual ID number to the population it belongs to. This will be the same population assignment as made by the assign_pop_inds() function
#    pop_scheme: list of ints, where each int is the population size of the population corrisponding to its position in the list
#returns popindex_byind: a dictionary; keys are the individual ID number, the value is the population number that individual belongs to
def assign_popdict(pop_scheme):
    full_sampsize = sum(pop_scheme)
    popindex_byind = {x:0 for x in range(full_sampsize)}
    for pop,size in enumerate(pop_scheme):
        for x in range(size):
            popindex_byind[(x + (size*pop))] = pop
    return popindex_byind

#For the multi-population simulation, takes the dictionary that has the genotype indexes grouped by populations, and returns a dictionary with the genotype index for each individual
#    genoind_bypops: dictionary; keys are the population id, values are a list. Each list has the genotype indexes (as in the position within the genotype list) that is assigned to each individual within that population
#returns ind_genoindex_dict: dictionary; keys are the individual ID, values are a tuple of the two indexes that are assigned to that individual
def get_ind_genoindex_multipop(genoind_bypops):
    ind_genoindex_dict = {}
    prev_pn = 0
    for num,p in enumerate(genoind_bypops.items()):
        for i,g in enumerate(p[1]):
            ind_genoindex_dict[(prev_pn+i)] = g
        prev_pn += len(p[1])
    return ind_genoindex_dict

#msprime does not do well if the migration matrix has all zeros for the migration between each population pair, so we don't want to run a simulation where the final theta has an all-zero migration matrix
#This funtion checks if that is the case for all the thetas that you are going to check, and returns the indexes of those bad thetas
#    theta: corrisponds to the values that make up each epoch. See the comments for the run_msprime_tskit() function for a more thorough description of this variable
#return bad_theta_nums: list; ints corrisponding to the thetas that shouldn't be used as the final epoch
def thetas_toskip(theta):
    bad_theta_nums = []
    for epoch in range(len(theta)):
        curr_theta = theta[:epoch+1]
        if(curr_theta[-1][0] == 'ooafrica'):
            continue
        if(curr_theta[-1][0] == 'mass' and args.ooafrica == False):
            bad_theta_nums.append(epoch)
        elif(set([all(x == 0) for x in curr_theta[-1][2][1]]) == {True}):
            bad_theta_nums.append(epoch)
    return bad_theta_nums


def get_epochs_pops_tosave(infile):
    epoch_df = read_csv(infile,delimiter='\t')
    epochs_pops_touse = {x:[] for x in set(epoch_df['epoch'])}
    for i,e in epoch_df.iterrows():
        epochs_pops_touse[e['epoch']].append(e['popnum'])
    return epochs_pops_touse



def write_genotyperep_file(genotypes,causal_pos,epoch,rep,outname):
    outfile = open('{0}.epoch{1}.rep{2}.genotypes.temp'.format(outname,epoch,rep),'w')
    outfile.write('{0}\t{1}\n'.format(rep,causal_pos))
    for pos,genos in genotypes.items():
        outfile.write('{0}\t'.format(pos))
        for g in genos[:-1]:
            outfile.write('{0}|{1};'.format(g[0],g[1]))
        outfile.write('{0}|{1}\n'.format(genos[-1][0],genos[-1][1]))
    outfile.close()

def get_genotypedict_fromfile(outname,epoch,rep):
    infile = open('{0}.epoch{1}.rep{2}.genotypes.temp'.format(outname,epoch,rep),'r')
    curr_dict = {}
    curr_causalpos = infile.readline().split('\n')[0].split('\t')[1]
    for line in infile:
        line = line.split('\n')[0].split('\t')
        temp_genos = []
        for g in line[1].split(';'):
            temp_genos.append(tuple([int(x) for x in g.split('|')]))
        curr_dict[int(line[0])] = temp_genos
    infile.close()
    return curr_dict,int(curr_causalpos)

#Runs the phenotype-generating simulation, for multiple populations and multiple epochs
#    theta: list of variables, each entry indicates an epoch. See the description for run_msprime_tskit() to see the full details of this variable
#    seq_len (int): length of the sequence that will be simulated
#    reps (int): number of replicates to simulate
#    pop_schemes (list): list of ints, one per population that will be simulated, indicating the number of individuals that will have 2 genotypes assigned to each
#    r (float): recombination rate, provided to the simulate function
#    mu (float): mutation rate, provided to the simulate function
#    outname (string): name of the file that will be created with the phenotype, one per epoch that is provided, as <outname>.epoch<num_epoch>.phenotypes
#    beta (string): method of choosing the beta value that is assigned to each individual. The only kind of distribution that is implemented so far
#Returns a list of sequence lengths; per epoch. 
#    seqsizes_byepoch (list of ints): a list of the largest position generated in each epoch, if a recombination map was provided; or the user-provided seq_len variable otherwise
def run_pheno_simulation_multipops(theta,seq_len,reps,pop_schemes,r,mu,outname,beta='normal',recomb_map=None):
    
    # genos_byepoch = []
    # causalpos_byepoch = []
    seqsizes_byepoch = [] #only for when a recombination map is supplied - it will hold the highest positional variant generated from all reps per epoch, and then return that to be used as the seq_len
    epochs_toskip = thetas_toskip(theta)
    for epoch in range(len(theta)):
        print('Starting epoch {0} replicates'.format(epoch))

        pop_sizes = [(i*2) for i in pop_schemes[epoch]] # Num individuals simulated, equal to twice the number of individuals, since each person is diploid
        sample_scheme = [i for i in pop_schemes[epoch]] # Num samples drawn from each pop for likelihood
        full_sampsize = sum(sample_scheme)
        print(pop_sizes,sample_scheme)
        genotype_index_bypops = assign_genotype_index_multipop(sample_scheme,pop_sizes) #randomly take the <samp_size> number of genomes simulated, and randomly assign to each individual 2 of them
        genotype_index_byinds = get_ind_genoindex_multipop(genotype_index_bypops)
        # print(genotype_index_byinds)
        # causalgenotypes_byrep = {x:[] for x in range(reps)}
        # causalpositions_byrep = {x:0 for x in range(reps)}
        # fullgenotypes_byrep = {x:[] for x in range(reps)}

        s_len = 0

        curr_theta = theta[:epoch+1]
        print('curr_theta = {0}'.format(curr_theta))
        if(epoch in epochs_toskip):
            print('Epoch {0} has no migration, skipping this epoch due to memory constraints'.format(epoch))
            continue
        # print('epoch {0} theta = {1}'.format(epoch,curr_theta))
        # tsreps = run_msprime_tskit(curr_theta,pop_sizes,seq_len,r,mu,reps,outname,epoch,recomb_map)
        tsreps = run_msprime_tskit(theta=curr_theta,
            sample_nums=pop_sizes,
            L=seq_len,
            r=r,
            mu=mu,
            R=reps,
            outname=outname,
            outname_epoch=epoch,
            recomb_map=recomb_map)
        
        print('replicate trees created; iterating through genotypes now')
        # pdb.set_trace()
        for rep,tree_sequence in enumerate(tsreps): 
            # pdb.set_trace()
            num_vars = 0
            for variant in tree_sequence.variants():
                num_vars += 1
            causal_var_id = random.randint(0,(num_vars-1))
            curr_causal_var = []
            curr_causal_pos = 0
            curr_full_vars_posgeno_dict = {}
            for variant in tree_sequence.variants():
                curr_full_vars_posgeno_dict[round(variant.site.position)] = list(variant.genotypes)
                if(variant.site.id == causal_var_id):
                    curr_causal_var = list(variant.genotypes)
                    curr_causal_pos = round(variant.site.position)
                if(round(variant.site.position) > s_len): #Record the largest position to use as the sequence length
                    s_len = round(variant.site.position)

            if(len(curr_causal_var) != (full_sampsize*2)):
                print('not enough causal variants in rep {0}'.format(rep))
                curr_causal_var = [0 for x in range((full_sampsize*2))]
                curr_full_vars_posgeno_dict[0] = [0 for x in range((full_sampsize*2))]
            # causalpositions_byrep[rep] = curr_causal_pos
            if(recomb_map is None): #If there's no recomb map, just use the user-supplied value
                s_len = seq_len

            curr_rep_fullgenos = {}
            for pos,geno in curr_full_vars_posgeno_dict.items():
                temp_fullgeno = []
                for indiv,index in genotype_index_byinds.items():
                    try:
                        temp_fullgeno.append((geno[index[0]],geno[index[1]]))
                    except:
                        print('error getting the full genotypes')
                        # print(rep,indiv,index,len(geno))
                curr_rep_fullgenos[pos] = temp_fullgeno
            # fullgenotypes_byrep[rep] = curr_rep_fullgenos
            write_genotyperep_file(curr_rep_fullgenos,curr_causal_pos,epoch,rep,outname)
        
        if(args.make_phenotype):
            # pdb.set_trace()
            print('finished iterating through trees, starting the phenotype calculations')
            causalgenotypes_byind = {x:[] for x in range(full_sampsize)}
            for r in range(reps):
                curr_fullgeno_dict,curr_causal_pos = get_genotypedict_fromfile(outname,epoch,r)
                for num,g in enumerate(curr_fullgeno_dict[curr_causal_pos]):
                    causalgenotypes_byind[num].append(g)
            # pdb.set_trace()
            phenotypes_byinds = {x:0 for x in range(full_sampsize)}
            beta_list = generate_betas(num_inds=reps,dist_type=beta)
            for i in range(full_sampsize):
                phenotypes_byinds[i] = estimate_pheno(causalgenotypes_byind[i],beta_list)
            write_phenofile('{0}.epoch{1}'.format(outname,epoch),phenotypes_byinds)
        seqsizes_byepoch.append(s_len)
        # genos_byepoch.append(fullgenotypes_byrep)
        # causalpos_byepoch.append(causalpositions_byrep)
    # return causalpos_byepoch,genos_byepoch

    #Return the seq_lens per epoch - if there is a recombination map, we use whatever the largest position is as the 'length', otherwise this will just be the user-supplied seq_len
    return seqsizes_byepoch 



#This function sets up the out_of_africa model, outlined in the msprime tutorial and expanded by user "slowkoni" on github, from the Gravel 2011 paper
#these values will be used to initialize a simulation so that additional user-definied events can simulated in more recent times
#The events in this model follow the pattern of:
#    Ancestral -> Africa -> { Africa, { Europe + East Asia } } -> { Africa, Europe, East Asia }
def outofafrica_model_parameters(n_samples):
    generation_time = 25

    m_AF_B = 15e-5
    m_AF_EU = 2.5e-5
    m_AF_AS = 0.78e-5
    m_EU_AS = 3.11e-5

    N_A = 7300 #ancestral_size 
    N_AF = 14474 #africa_size 
    N_EU0 = 1032 #out-to-europe-size
    N_AS0 = 550 #out-to-asia-size
    N_AF_B = 1861 #out-of-africa-size

    T_B = 51000 #merge-to-africa time
    T_EuAs = 23000 #merge-europe-asia-time
    T_AF = 148000 #africa-expansion-time

    asia_growth_rate = 0.38 
    europe_growth_rate = 0.48

     # Calculate the final sizes, or in coalescent terms, the starting sizes, of the
    # Europe and East Asia populations which under the Gravel et al. 2011 out of africa
    # model experience exponential growth after diverging from each other going
    # separate ways in the world. Command line accepts values in percentages as given in
    # the Gravel et al. paper. We just need to know the starting effective size, starting
    # as in the present day effective size, as the simulation goes backward in time.
    europe_final_size = N_EU0 / math.exp(-(europe_growth_rate/100.) * (T_EuAs/generation_time))
    asia_final_size = N_AS0 / math.exp(-(asia_growth_rate/100.) * (T_EuAs/generation_time))

    migration_matrix = [
        [      0, m_AF_EU, m_AF_AS],
        [m_AF_EU,       0, m_EU_AS],
        [m_AF_AS, m_EU_AS,       0],
    ]
    
    europe_asia_merge_time = T_EuAs/generation_time

    population_configurations = [
        ms.PopulationConfiguration(
            sample_size=n_samples[0], initial_size=N_AF),
        ms.PopulationConfiguration(
            sample_size=n_samples[1], initial_size=europe_final_size,
            growth_rate=europe_growth_rate/100.),
        ms.PopulationConfiguration(
            sample_size=n_samples[2], initial_size=asia_final_size,
            growth_rate=asia_growth_rate/100.)
    ]

    demographic_events = [
        # All the next events, until indicated below, are coincident and thus really one
        # event
        
        # The Europe (pop 1) and East Asia (pop 2) populations merge and become population 1
        ms.MassMigration(
            time=europe_asia_merge_time, source=2, destination=1, proportion=1.0),
        # Migration rates must now refelect migration between the original African population
        # and the merged Europe/East Asian population which are still separate at this point
        ms.MigrationRateChange(time=europe_asia_merge_time, rate=0),
        ms.MigrationRateChange(
            time=europe_asia_merge_time, rate=m_AF_B, matrix_index=(0, 1)),
        ms.MigrationRateChange(
            time=europe_asia_merge_time, rate=m_AF_B, matrix_index=(1, 0)),
        # Finally, the effective size of the merged population (pop 1 now) is different
        # otherwise it would be whatever the shrinking Europe population size is/was.
        ms.PopulationParametersChange(
            time=europe_asia_merge_time, initial_size=N_AF_B,
            growth_rate=0, population_id=1),

        # Now we are backward further in time
        # Next, the migrating out of africa population (currently pop 1) joins to the
        # population of origin (pop 0), the african population
        ms.MassMigration(
            time=T_B/generation_time, source=1, destination=0, proportion=1.0),

        # In the final event of the model, the African population (pop 0, the only one left)
        # reduces in size to the ancestral population size until the MRCA (end of the simulation)
        ms.PopulationParametersChange(
            time=T_AF/generation_time,
            initial_size=N_A, population_id=0)
    ]

    return(population_configurations, migration_matrix, demographic_events)



if __name__ == "__main__":
    args = parser.parse_args()
    if(args.beta_type is None):
        beta = "normal"
    else:
        beta = args.beta_type

    if(args.recomb_map is None):
        recomb_map = None
    else:
        recomb_map = args.recomb_map

    if(args.window == None):
        window = 1000
    else:
        try:
            window = int(args.window)
        except:
            window = str(args.window)

    if(args.epochpops_file is None):
        epochpops_file = None
    else:
        epochpops_file = args.epochpops_file

    if(args.input_file is None):
        cpos_pheno_byinds,pgenos_byinds = run_pheno_simulation(int(args.samp_size),int(args.seq_len),int(args.L),int(args.num_individuals),args.out_name,beta)
        write_genovcf(pgenos_byinds,cpos_pheno_byinds,'{0}.pheno'.format(args.out_name),int(args.num_individuals),int(args.seq_len),window)

        cpos_geno_byind,genos_byinds = run_geno_simulation(int(args.samp_size),int(args.seq_len),int(args.L),int(args.num_individuals))
        write_genovcf( genos_byinds,cpos_geno_byind,'{0}.geno'.format(args.out_name),int(args.num_individuals),int(args.seq_len),window)
    else:
        
        theta,sample_schemes = read_input_file_full(args.input_file)
        popdicts_by_epoch = {}
        if(epochpops_file is None):
            epochs_toskip = thetas_toskip(theta)
            for ep,sampsch in enumerate(sample_schemes):
                if(ep in epochs_toskip):
                    continue
                popdicts_by_epoch[ep] = assign_popdict(sampsch)
        else:
            epochpops_tosave = get_epochs_pops_tosave(epochpops_file)
            epochs_toskip = []
            for e in range(len(theta)):
                if(e not in epochpops_tosave.keys()):
                    epochs_toskip.append(e)
                for ep,sampsch in enumerate(sample_schemes):
                    if(ep in epochs_toskip):
                        continue
                    popdicts_by_epoch[ep] = assign_popdict(sampsch)
        if(recomb_map is None): #Run the simulations using the provided sequence length and recombinatin rate, if there's no recombination map supplied
            updated_seqlen_byepoch = run_pheno_simulation_multipops(theta=theta,seq_len=int(args.seq_len),
                reps=int(args.L),pop_schemes=sample_schemes,r=float(args.recombination_rate),
                mu=float(args.mutation_rate),outname=args.out_name,beta=beta)
        else: #Otherwise, we can just give values of 0 for those two variables, since they can't be used with the recombination map
            updated_seqlen_byepoch = run_pheno_simulation_multipops(theta=theta,reps=int(args.L),pop_schemes=sample_schemes,
                recomb_map=recomb_map,seq_len=0,r=0,
                mu=float(args.mutation_rate),outname=args.out_name,beta=beta)
        
        print('finished generating simulation files; starting to record vcf files')
        if(epochpops_file is None):
            for epoch in popdicts_by_epoch.keys():
                #Since we don't run a simulation where the final migration matrix is all zero, we want the output vcf files to match up with the output phenotypes
                curr_epoch = 0
                while curr_epoch in epochs_toskip:
                    curr_epoch += 1
                print('starting creation of vcf for epoch {0} simulation'.format(curr_epoch))
                curr_popid_dict = popdicts_by_epoch[curr_epoch]
                write_genovcf(reps=int(args.L),
                    epoch=epoch,
                    num_inds=len(popdicts_by_epoch[epoch].values()),
                    outname=args.out_name,
                    seq_len=updated_seqlen_byepoch[epoch],
                    # seq_len=int(args.seq_len),
                    window_spacer=window,
                    popid_dict=curr_popid_dict,
                    chrm=4)
                curr_epoch += 1
        else:
            for epoch,pops in epochpops_tosave.items():
                for p in pops:
                    curr_popdict = {}
                    for inds in popdicts_by_epoch[e].items():
                        if(inds[1] == p):
                            curr_popdict[inds[0]] = inds[1]
                    print('starting creation of vcf for epoch {0} simulation'.format(epoch))
                    # curr_outname = '{0}.population{1}'.format(args.out_name,p)
                    write_genovcf(reps=int(args.L),
                        epoch=epoch,
                        num_inds=len(curr_popdict.values()),
                        outname=args.out_name,
                        seq_len=updated_seqlen_byepoch[epoch],
                        # seq_len=int(args.seq_len),
                        window_spacer=window,
                        popid_dict=curr_popdict,
                        chrm=4,
                        pop_num=p)
    














